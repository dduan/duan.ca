<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Daniel Duan">
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://duan.ca/2015/04/18/swift-function-fun-facts/">
    <meta property="og:site_name" content="Daniel Duan's Website">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Swift Function Fun Facts">
    <meta property="article:published_time" content="2015-04-18"><meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@daniel_duan">
    <meta name="twitter:creator" content="@Daniel Duan">
    <meta name="apple-mobile-web-app-title" content="Daniel Duan">
    <title>Swift Function Fun Facts</title>
    <link rel="alternate" type="application/rss+xml" title="Daniel Duan's Website" href="/feed.xml">
    <link rel="canonical" href="https://duan.ca/2015/04/18/swift-function-fun-facts/">
    <link rel="stylesheet" href="/styles.css"></link>
    <link rel="shortcut icon" href="/favicon.ico">
</head>
<body><article>
    <h1>Swift Function Fun Facts</h1>
    <nav>
        <p class="metainfo article-meta">
            <a href="/">Daniel Duan</a>
            ·
            <time datetime="2015-04-18" itemProp="datePublished">2015-04-18</time>
        </p>
    </nav><p>You love Swift. You want to write a class that does HTTP, it might have
methods like the following:</p>
<pre><code class="language-swift">func get(URLString:String, params:[String:AnyObject],
    headers:[String:String])
func post(URLString:String, params:[String:AnyObject],
    headers:[String:String])
func put(URLString:String, params:[String:AnyObject],
    headers:[String:String])
// and more for HEAD, OPTIONS …

</code></pre>
<p>But you don't want to force your user to supply all arguments each time. You
know that Swift supports default arguments, so you added some. Take GET as an
example:</p>
<pre><code class="language-swift">func get(URLString:String, params:[String:AnyObject]=[:],
    headers:[String:String]=[:])

</code></pre>
<p>Now users can do things like</p>
<p>{% highlight swift %}
get(&quot;http://github.com&quot;)
get(&quot;http://httpbin.org/get&quot;, headers:[&quot;Answer&quot;:42])
{% endhighlight %}</p>
<p>That's flexible! Woohoo!</p>
<p>After you thought about implementing these, though, you realize that
<code>HTTPMethod</code> is merely a property on <code>NSURLRequest</code>. In other words, all of
the previous methods can share the same implementation. In honor of the DRY
principle, you write a function that accepts the method as an arguments and
the previous functions each forwards the arguments to this function:</p>
<pre><code class="language-swift">func impl(method:String, URLString:String,
    params:[String:AnyObject],
    headers:[String:String])
{
    // …
}

func get(URLString:String, params:[String:AnyObject]=[:],
    headers:[String:String]=[:])
{
    impl(&quot;GET&quot;, URLString:URLString, params:params,
        headers:headers)
}

func post(URLString:String, params:[String:AnyObject]=[:],
    headers:[String:String]=[:])
{
    impl(&quot;POST&quot;, URLString:URLString, params:params,
        headers:headers)
}
</code></pre>
<p>This seems like a sensible solution. Except that later you realize that there
needs to be more parameters for each function, so in the end, each function
looks like this:</p>
<pre><code class="language-swift">func post(
    URLString             : String,
    params                : [String:AnyObject]       = [:],
    json                  : [String:AnyObject]?      = nil,
    headers               : [String:AnyObject]       = [:],
    auth                  : (String,String)?         = nil,
    allowRedirects        : Bool                     = true,
    requestBody           : NSData?                  = nil,
    URLQuery              : String?                  = nil,
    asyncCompletionHandler: ((HTTPResult!) -&gt; Void)? = nil
    ) -&gt; HTTPResult {
    return impl(
        &quot;POST&quot;,
        URLString             : URLString,
        params                : params,
        json                  : json,
        headers               : headers,
        auth                  : auth,
        data                  : requestBody,
        URLQuery              : URLQuery,
        redirects             : allowRedirects,
        asyncCompletionHandler: asyncCompletionHandler
    )
}
</code></pre>
<p>Remembering that your goal is to respect DRY, and there are now giant blocks
of code that all look the same except that first argument to <code>impl()</code>, you
became determined to find a better alternative.</p>
<p>Well, why not give currying a try? This example of currying with Swift comes
to your mind:</p>
<p>{% highlight swift %}
func add(a:Int)(b:Int) -&gt; Int { return a + b }
let add3 = add(3)
add3(b:2) // 5
{% endhighlight %}</p>
<p>If we apply this technique and treat <code>method</code> in <code>impl()</code> as <code>a</code> in the
example, we would get:</p>
<pre><code class="language-swift">func impl(method:String)(
    URLString:String,
    params:[String:AnyObject],
    headers:[String:String],
    …)
{
    // …
}
let get = impl(&quot;GET&quot;)
let post = impl(&quot;POST&quot;)
</code></pre>
<p>right?  However, you are forcing users to supply each argument again. To make
things worse, the number of arguments is a lot larger.</p>
<p>Hmm, but that's a solved problem, just add default values to <code>impl()</code>'s
parameters:</p>
<pre><code class="language-swift">func impl(method:String)(
    URLString:String,
    params:[String:AnyObject] = [:],
    headers:[String:String] = [:],
    …)
{
    // …
}
</code></pre>
<p>Ta-da! Wait a minute, Xcode now refuse to compile you code! <code>Default argument is only permitted for a non-curried function parameter</code>, it saids.</p>
<p>Stubborn as you are, you decide that perhaps the Swift team hasn't got around
to implementing this feature for curry syntax yet. Functions are first-class
citizens! Surely if you return a function with default arguments…?</p>
<pre><code class="language-swift">func methodFactory(method:String)
    -&gt; (params:[String:AnyObject] = [:],
        headers:[String:String] = [:], …)
    -&gt; Void
{
    return {(params, headers, …) in
        impl(method, params:params, headers:headers, …)
    }
}

let get = methodFactory(&quot;GET&quot;)
let post = methodFactory(&quot;POST&quot;)
</code></pre>
<p>Turns out, this manual form of currying only works when default arguments
aren't involved!</p>
<p>Now, you hate Swift.</p>
<p>(Just to be clear, I don't really hate Swift as in, uh, <em>hate</em> Swift. Judgning
from some comments, I might have failed to convey the lightheartedness that
I felt writing this up. It's really like saying to a friend &quot;I hate you&quot; after
he/she pulls a prank on you.)</p>

</article>
<footer>
    <hr />
    <p class="metainfo article-meta">
        <a href="/articles/">More Articles</a>
        ·
        <a href="/tag/swift/">Swift</a>
    </p>
</footer></body>
</html>