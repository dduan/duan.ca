<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Swift Algebraic Data Types</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,300i,600">
  <link rel="stylesheet" href="/style.css">
  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Daniel Duan" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v1.4.0 -->
<title>Swift Algebraic Data Types - Daniel Duan</title>
<meta property="og:title" content="Swift Algebraic Data Types" />
<meta name="description" content="The Basics" />
<meta property="og:description" content="The Basics" />
<meta property="og:site_name" content="Daniel Duan" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-07-12T00:00:00-07:00" />
<link rel="next" href="/2015/11/01/char-star-star-in-swift/" title="char ** in Swift" />
<link rel="prev" href="/2015/07/04/lets-build-a-cat-in-swift-2/" title="Let&#39;s Build A &#39;cat&#39; In Swift 2" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@daniel_duan" />
<meta name="twitter:creator" content="@Daniel Duan" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Swift Algebraic Data Types",
    "datePublished": "2015-07-12T00:00:00-07:00",
    "description": "The Basics",
    "url": "/2015/07/12/swift-algebraic-data-types/"
  }
</script>
<!-- End Jekyll SEO tag -->
</head>
<body>
  <div class="container">
    <header class="masthead">
  <h1 class="masthead-title--small">
    <a href="/archive">Daniel Duan</a>
  </h1>
</header>
<div class="content post">
  <h1 class="post-title">Swift Algebraic Data Types</h1>
  <div class="post-date">
    <time>12 Jul 2015</time>
     | 

<div class="post-tags">

  <a href="/tag/Swift">Swift</a>

</div>


  </div>
  <h2 id="the-basics">The Basics</h2>

<p><a href="https://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic Data Type</a> is a fancy name for ‚Äúa type creaded by combining other
types‚Äù in programming languages. One aspect of the ‚Äúalgebraic-ness‚Äù is how
many potential new values there are for the new type, given a set of type as
its building block.</p>

<p>To better illustrate this, consider the following example in Swift.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">StarkChild</span> <span class="p">{</span> <span class="k">case</span> <span class="kt">Rickon</span><span class="p">,</span> <span class="kt">Bran</span><span class="p">,</span> <span class="kt">Arya</span><span class="p">,</span> <span class="kt">Sansa</span><span class="p">,</span> <span class="kt">Robb</span><span class="p">,</span> <span class="kt">Jon</span> <span class="p">}</span>

<span class="kd">enum</span> <span class="kt">Direwolf</span> <span class="p">{</span> <span class="k">case</span> <span class="kt">Shaggydog</span><span class="p">,</span> <span class="kt">Summer</span><span class="p">,</span> <span class="kt">Nymeria</span><span class="p">,</span> <span class="kt">Lady</span><span class="p">,</span> <span class="kt">Greywind</span><span class="p">,</span> <span class="kt">Ghost</span> <span class="p">}</span>

<span class="kd">enum</span> <span class="kt">Actor</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Wolf</span><span class="p">(</span><span class="kt">Direwolf</span><span class="p">)</span>
    <span class="k">case</span> <span class="kt">Person</span><span class="p">(</span><span class="kt">StarkChild</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Parters</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">wolf</span><span class="p">:</span> <span class="kt">Direwolf</span>
    <span class="k">var</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">StarkChild</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">StarkChild</code> and <code class="highlighter-rouge">Direwolf</code> each has 6 potential values. Combining them, we
get two new types.</p>

<p>Question: how many potentiol values are there for <code class="highlighter-rouge">Actor</code>? How many for
<code class="highlighter-rouge">Parters</code>?</p>

<hr />

<p>An <code class="highlighter-rouge">Actor</code> can be either a <code class="highlighter-rouge">StarkChild</code> or a <code class="highlighter-rouge">DireWolf</code>, therefore it has <code class="highlighter-rouge">6
+ 6 = 12</code> potential values ‚Äì the <em>sum</em> of <code class="highlighter-rouge">Child</code>‚Äôs and <code class="highlighter-rouge">DireWolf</code>‚Äôs values.</p>

<p>A <code class="highlighter-rouge">Partners</code> requires us to select one value from <code class="highlighter-rouge">Child</code> and one from
<code class="highlighter-rouge">DireWolf</code>, resulting in <code class="highlighter-rouge">6 * 6 = 36</code> potential values ‚Äì the <em>product</em> of
<code class="highlighter-rouge">Child</code>‚Äôs and <code class="highlighter-rouge">DireWolf</code>‚Äôs values.</p>

<p><code class="highlighter-rouge">Actor</code>, an <code class="highlighter-rouge">enum</code>, is a <em>sum</em> type. <code class="highlighter-rouge">Parters</code>, a <code class="highlighter-rouge">struct</code>, is a <em>product</em>
type. Here, <code class="highlighter-rouge">Parters</code> could easily be defined as a <code class="highlighter-rouge">class</code> or a <code class="highlighter-rouge">tuple</code> and
remain a <em>product</em> type. Because we can create product or sum types in these
direct ways, we can say Swift has first class support for Algebraic Data
Types.</p>

<h2 id="the-crossovers">The Crossovers</h2>

<p>However, the story doesn‚Äôt stop here. In Swift, an <code class="highlighter-rouge">enum</code>‚Äôs option can have
multiple values. If it happens to be the only option, then this
<code class="highlighter-rouge">enum</code>effectively becomes a <em>product</em> type:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// there are 6 * 6 = 36 potential values for Parters</span>
<span class="kd">enum</span> <span class="kt">Parters</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Value</span><span class="p">(</span><span class="nv">wolf</span><span class="p">:</span> <span class="kt">DireWolf</span><span class="p">,</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">StarkChild</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Incidentally, this makes <code class="highlighter-rouge">enum</code> similar to <code class="highlighter-rouge">data</code> in Haskell, where <em>product</em>
and <em>sum</em> types can be created with a unified construct ‚Äì <code class="highlighter-rouge">data</code>.</p>

<p>In C and C++, <code class="highlighter-rouge">union</code>s are the closest thing to <em>sum</em> types. However, <code class="highlighter-rouge">union</code>
is hardly used to combine arbitrary types due to its lack of associated
values. What do people do in need of <em>sum</em> types? They make do with product
types. Here‚Äôs one way to achive that in Swift:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Actor.value can have only 6 + 6 = 12 potential values thanks to</span>
<span class="c1">// manual enforcement</span>
<span class="kd">class</span> <span class="kt">Actor</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">child</span><span class="p">:</span> <span class="kt">StarkChild</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">wolf</span><span class="p">:</span> <span class="kt">Direwolf</span><span class="p">?</span>

    <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Any</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">child</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">?</span> <span class="n">wolf</span><span class="o">!</span> <span class="p">:</span> <span class="n">child</span><span class="o">!</span>
        <span class="p">}</span>
        <span class="nf">set</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">newValue</span> <span class="k">is</span> <span class="kt">StarkChild</span> <span class="p">{</span>
                <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">newValue</span> <span class="k">as!</span> <span class="kt">StarkChild</span><span class="p">)</span>
                <span class="n">wolf</span> <span class="o">=</span> <span class="kc">nil</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">newValue</span> <span class="k">is</span> <span class="kt">Direwolf</span> <span class="p">{</span>
                <span class="n">wolf</span> <span class="o">=</span> <span class="p">(</span><span class="n">newValue</span> <span class="k">as!</span> <span class="kt">Direwolf</span><span class="p">)</span>
                <span class="n">child</span> <span class="o">=</span> <span class="kc">nil</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">wolf</span><span class="p">:</span> <span class="kt">Direwolf</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">wolf</span> <span class="o">=</span> <span class="n">wolf</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">child</span><span class="p">:</span> <span class="kt">StarkChild</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">child</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">fatalError</span><span class="p">(</span><span class="s">"must initialize with a child or a wolf"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>It‚Äôs‚Ä¶ ugly.</p>

<h2 id="recursion-types">Recursion Types</h2>

<p>Besides <em>sum</em> and <em>product</em>, another common class of algebraic type is
recursion types. The interesting bit here is that Swift struggles to support
it. In WWDC 2015, it was announced that <code class="highlighter-rouge">enum</code>s can be defined recursively in
Swift 2:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Tree</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Empty</span>
    <span class="n">indirect</span> <span class="k">case</span> <span class="kt">Node</span><span class="p">(</span><span class="kt">Tree</span><span class="p">,</span> <span class="kt">Tree</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>As of this writing, Xcode 7 beta 3 has not delivered this feature yet.
Also, it‚Äôs a good bet that <code class="highlighter-rouge">indirect</code> is not going to be available in tuple
aliases, such as:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">Node</span> <span class="o">=</span> <span class="p">(</span><span class="n">indirect</span> <span class="kt">Node</span><span class="p">,</span> <span class="n">indirect</span> <span class="kt">Node</span><span class="p">)</span>
</code></pre>
</div>

<p>I hope this is on the Swift team‚Äôs (understandably) gigantic todo list üòâ.</p>


</div>

  </div>
</body>
</html>
