<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Daniel Duan">
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://duan.ca/2015/11/01/char-star-star-in-swift/">
    <meta property="og:site_name" content="Daniel Duan's Website">
    <meta property="og:type" content="article">
    <meta property="og:title" content="char ** in Swift">
    <meta property="article:published_time" content="2015-11-01"><meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@daniel_duan">
    <meta name="twitter:creator" content="@Daniel Duan">
    <meta name="apple-mobile-web-app-title" content="Daniel Duan">
    <title>char ** in Swift</title>
    <link rel="alternate" type="application/rss+xml" title="Daniel Duan's Website" href="/feed.xml">
    <link rel="canonical" href="https://duan.ca/2015/11/01/char-star-star-in-swift/">
    <link rel="stylesheet" href="/styles.css"></link>
    <link rel="shortcut icon" href="/favicon.ico">
</head>
<body><article>
    <h1>char ** in Swift</h1>
    <nav>
        <p class="metainfo article-meta">
            <a href="/">Daniel Duan</a>
            Â·
            <time datetime="2015-11-01" itemProp="datePublished">2015-11-01</time>
        </p>
    </nav><p>A &quot;string&quot; in C is just a continuous chunk of <code>char</code> values in memory with
<code>\0</code> at the end. To reference it, a variable of type <code>char *</code> is used to store
the address of the first <code>char</code> (commonly known as a pointer ðŸ˜‰).  It's common
to have string manipulating functions take this form:</p>
<pre><code class="language-swift">void foo(char **errorMessage) {
    // ...
}
</code></pre>
<p>To mutate the arugment <code>errorMessage</code> of type <code>char *</code>, <code>foo</code> takes a pointer
to it, <code>(char *)*</code>.</p>
<!-- raw HTML omitted -->
<p>How do we call <code>foo</code> in Swift?</p>
<p>Here's the tl;dr. We can wrap it in a Swift function that have the same
interface:</p>
<pre><code class="language-swift">func fooSwift(inout errorMessage: String?) {
    var message: UnsafeMutablePointer&lt;CChar&gt; = nil

    foo(&amp;message)
    errorMessage = String.fromCString(message)
}
</code></pre>
<p><code>errorMessage</code> will contain whatever our C function <code>foo</code> assigns to it.</p>
<!-- raw HTML omitted -->
<p>So, what's really going on here?</p>
<p>Inspecting <code>foo</code>'s signature in Swift, we see</p>
<pre><code class="language-swift">func foo(errorMessage: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;CChar&gt;&gt;)
</code></pre>
<p>â€¦ okey, <code>errorMessage</code>'s type is little intimidating to someone who doesn't
use C functions in Swift everyday (like me)!</p>
<p>Let's break it down. Swift does a ton of work for us to interoperate with C:</p>
<ol>
<li>
<p><code>CChar</code> is Swift's name for <em><code>char</code> in C</em> (shocking, amiright?)</p>
</li>
<li>
<p><code>UnsafeMutablePointer&lt;Type&gt;</code> roughly translates to <code>Type *</code>, so
syntactically, we can see why
<code>UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;CChar&gt;&gt;</code> is used to bridge the
C type <code>(char *)*</code>.</p>
</li>
<li>
<p>A function that takes <code>UnsafeMutablePointer&lt;Type&gt;</code> argument accepts
<code>inout Type</code> values. Therefore, we can look at <code>foo</code> as</p>
<pre><code>foo(inout errorMessage: UnsafeMutablePointer&lt;CChar&gt;)
</code></pre>
</li>
<li>
<p>Swift acknowledge C's string representation and provides convenient
methods for converting <code>char *</code> / <code>UnsafeMutablePointer&lt;CChar&gt;</code> to its own
<code>String</code> type (<code>String.fromCString()</code>).</p>
</li>
</ol>
<p>Hopefully you can see how <code>fooSwift</code> works now.</p>
<!-- raw HTML omitted -->
<p>Taking a step back, to deal with <code>char **</code> in Swift, we overcame 2 obstacles:</p>
<ol>
<li>
<p>The difference in string representation between C and Swift.</p>
</li>
<li>
<p>Compared to C pointers, Swift's <code>inout</code> expresses mutability of function
arguments in a more restricted way. We can't nest <code>inout</code>s to represent
the infinite layers of indirections that pointers achieve.</p>
</li>
</ol>

</article>
<footer>
    <hr />
    <p class="metainfo article-meta">
        <a href="/articles/">More Articles</a>
        Â·
        <a href="/tag/swift/">Swift</a>
        Â·
        <a href="/tag/c/">C</a>
    </p>
</footer></body>
</html>