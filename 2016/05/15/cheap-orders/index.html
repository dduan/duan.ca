<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Daniel Duan">
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://duan.ca/2016/05/15/cheap-orders/">
    <meta property="og:site_name" content="Daniel Duan's Website">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Cheap Orders">
    <meta property="article:published_time" content="2016-05-15T17:42:27-07:00"><meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@daniel_duan">
    <meta name="twitter:creator" content="@Daniel Duan">
    <meta name="apple-mobile-web-app-title" content="Daniel Duan">
    <title>Cheap Orders</title>
    <link rel="alternate" type="application/rss+xml" title="Daniel Duan's Website" href="/feed.xml">
    <link rel="canonical" href="https://duan.ca/2016/05/15/cheap-orders/">
    <link rel="stylesheet" href="/styles.css"></link>
    <link rel="shortcut icon" href="/favicon.ico">
</head>
<body><article>
    <h1>Cheap Orders</h1>
    <nav>
        <p class="metainfo article-meta">
            <a href="/articles">Daniel Duan</a>
            ·
            <time datetime="2016-05-15T17:42:27-07:00" itemProp="datePublished">2016-05-15</time>
        </p>
    </nav><p>How to create order? If the second law of thermal dynamics tells us anything,
we'd better get to work, right?
{: .lead}</p>
<p>Before going full existential, let's limit &quot;order&quot; to Swift's set and
dictionaries -- there is none. Of course, you can take values/keys out and
sort them. But what if all you care about is <em>some</em> order?</p>
<hr />
<p>Recently, I wrote</p>
<pre><code class="language-swift">enum Token {
  static let all = [
    &quot;=&quot;: .Equal,
    &quot;-&quot;: .Minus,
    // more token mappings …
  ]
  case Equal
  case Minus
  // more tokens …
}
</code></pre>
<p>… in the hope that I can take each value from <code>Token.all.keys</code> and see if
a prefix of a string is a matching token. It started to fail as the tokens
expands to multiple characters:</p>
<pre><code class="language-swift">enum Token {
  static let all = [
    &quot;=&quot;: .Equal,
    &quot;-&quot;: .Minus,
    // more token mappings …
    &quot;==&quot;: .Equality,
    &quot;-&gt;&quot;: .Arrow,
    // more token mappings …
    &quot;===&quot;: .Identity,
    // more token mappings …
  ]
  case Equal
  case Minus
  case Equality
  case Arrow
  case Identity
  // … more tokens …
}
</code></pre>
<p><code>-&gt;</code> could get a match with <code>-</code> and <code>===</code> would match to either <code>==</code> or <code>=</code>,
etc.</p>
<p>Since the tokens in this exercise have at most 3 characters, I decided to
group them by length and match from the longer group first. The groups became:</p>
<pre><code class="language-swift">enum Token {
  static private let group1 = [
    &quot;=&quot;: .Equal,
    &quot;-&quot;: .Minus,
    // more token mappings …
  ]

  static private let group2 = [
    &quot;==&quot;: .Equality,
    &quot;-&gt;&quot;: .Arrow,
    // more token mappings …
  ]

  static private let group3 = [
    &quot;===&quot;: .Identity,
    // more token mappings …
  ]
}
</code></pre>
<p>Now I can choose which group to take values first. There's a way to do it
without adding some control flow logic:</p>
<pre><code class="language-swift">[group3.keys, group2.keys, group3.keys].flatten()
</code></pre>
<p>Even better, I'll make it a lazy property…</p>
<pre><code class="language-swift">enum Token {
  static var all = {
    [group3.keys, group2.keys, group3.keys].flatten()
  }()
}
</code></pre>
<p>…except an important piece of information is missing from the property: what's
<code>all</code>'s type? Turns out, it's become</p>
<pre><code class="language-swift">FlattenCollection&lt;Array&lt;LazyMapCollection&lt;Dictionary&lt;String, Token&gt;, String&gt;&gt;&gt;
</code></pre>
<p>Ahh, it seems that in the pursue of cheap, lazy creation of these structures,
we are forced to deal with a bunch of type wrappers, each having a good reason
to be here!</p>
<p>But I really just need something like <code>Array&lt;String&gt;</code> for the consumer. If
only there's a way to make all this stuff go away from my type signature, as
if they are <a href="http://robnapier.net/erasure">erased</a> :).</p>
<p>Okay, I'm talking about <code>AnySequence</code> now. Rob Napier has an excellent post on
this topic <a href="http://robnapier.net/erasure">here</a> if you need to catch up. Our
code eventually end up like this:</p>
<pre><code class="language-swift">enum Token {
  static var all: AnySequence&lt;String&gt; = {
    AnySequence(
      [group3.keys, group2.keys, group3.keys]
        .flatten())
  }()
}
</code></pre>
<p>Instead of <code>Array&lt;String&gt;</code>, we have an <code>AnySequence&lt;String&gt;</code>. Our tokens now
gets checked with the correct order. We didn't need to sort the entire set of
tokens, nor did we do any heavy data massage upfront, making a bunch of copies
along the way.</p>
<hr />
<p>Looking back, this post really failed to capture the eureka moment as I came
up with the erasure method. I discovered a series of small challenges and got
help from Swift's designers in each step. Everything fell together in the end.</p>

</article>
<footer>
    <hr />
    <p class="metainfo article-meta">
        <a href="/articles/">More Articles</a>
        ·
        <a href="/tag/swift/">Swift</a>
    </p>
</footer></body>
</html>