<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Daniel Duan">
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://duan.ca/2018/08/25/a-tale-of-two-dates/">
    <meta property="og:site_name" content="Daniel Duan's Website">
    <meta property="og:type" content="article">
    <meta property="og:title" content="A Tale of Two Dates">
    <meta property="article:published_time" content="2018-08-25"><meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@daniel_duan">
    <meta name="twitter:creator" content="@Daniel Duan">
    <meta name="apple-mobile-web-app-title" content="Daniel Duan">
    <title>A Tale of Two Dates</title>
    <link rel="alternate" type="application/rss+xml" title="Daniel Duan's Website" href="/feed.xml">
    <link rel="canonical" href="https://duan.ca/2018/08/25/a-tale-of-two-dates/">
    <link rel="stylesheet" href="/styles.css"></link>
    <link rel="shortcut icon" href="/favicon.ico">
</head>
<body><article>
    <h1>A Tale of Two Dates</h1>
    <nav>
        <p class="metainfo article-meta">
            <a href="/">Daniel Duan</a>
            ·
            <time datetime="2018-08-25" itemProp="datePublished">2018-08-25</time>
        </p>
    </nav><p>Recently, I discovered a curious thing about <code>Date</code>s in two large projects
I work on. Simply put, both projects receives, from various HTTP endpoints, the
same object component: a timestamp, and a duration. Combining these two pieces,
both projects derives two <code>Foundation.Date</code>s to represent a time range. So far,
so good.</p>
<p>However, project <code>A</code> uses <code>Fonudation.DateInterval</code> to represent this concept,
while project <code>B</code> uses <code>Range&lt;Date&gt;</code>. But why? Why represent the same component
differently? What a gigantic waste of brain power for everyone on both projects!</p>
<p>So I set out to unify this thing. Wherever a <code>Range</code> literal is used, I swap in
<code>DateInterval.init(start:end:)</code>; <code>Range.lowerBound</code> becomes
<code>DateInterval.start</code>; <code>Range.upperBound</code> becomes <code>DateInterval.end</code>, etc. It
didn't take long to complete the conversion to <code>DateInterval</code> in project <code>B</code>,
now it builds and runs!</p>
<p>Oh, wait, why are some tests failing in project <code>B</code>? Shouldn't this just be an
mechanical change?</p>
<p>I spent time investigating. The failing tests are for some very specific
business logic that I'm not familiar with. So things took a while to become
clear. What felt like a long time later, I realized my mistake.</p>
<p>(I'm sorry if this has been obvious to you. You are a better Swift programmer!)</p>
<p>Somewhere in project <code>B</code> is the following:</p>
<pre><code class="language-swift">struct Item {
    let range: Range&lt;Date&gt;
}

struct Container {
    let items: [Item]
}

func containerFactory(range: Range&lt;Date&gt;, items: [Item]) -&gt; Container {
    /// pretend there's more code here

    return Conatiner(items: items.filter { $0.range.contains(range.lowerBound) })
}
</code></pre>
<p>And of course, after my &quot;refactor&quot;, it became</p>
<pre><code class="language-swift">struct Item {
    let range: DateInterval
}

struct Container {
    let items: [Item]
}

func containerFactory(range: DateInterval, items: [Item]) -&gt; Container {
    /// pretend there's more code here

    return Conatiner(items: items.filter { $0.range.contains(range.start) })
}
</code></pre>
<p>Tests for <code>containerFactory</code> failed. And here's why: <strong><code>DateInterval.contains</code>
is inclusive for its upper bound (<code>.end</code>), whereas <code>Range.contains</code> isn't!</strong> You
can see it plainly by running the following</p>
<pre><code class="language-swift">import Foundation

let sooner = Date(timeIntervalSince1970: 0)
let later = sooner.addingTimeInterval(1000)

DateInterval(start: sooner, end: later).contains(later) // true
(sooner..&lt;later).contains(later)                        // false
</code></pre>
<p>So here's what stumped me:</p>
<ol>
<li>
<p>The 2 projects chose to interpret the same component differently, which
I didn't not expect.</p>
</li>
<li>
<p>I didn't know how <code>Foundation.DateInterval</code> works.</p>
</li>
</ol>
<p>Well, today I learned.</p>

</article>
<footer>
    <hr />
    <p class="metainfo article-meta">
        <a href="/articles/">More Articles</a>
        ·
        <a href="/tag/swift/">Swift</a>
        ·
        <a href="/tag/foundation/">Foundation</a>
    </p>
</footer></body>
</html>