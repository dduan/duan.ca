<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Daniel Duan">
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://duan.ca/2019/07/01/combine-hygiene/">
    <meta property="og:site_name" content="Daniel Duan's Website">
    <meta property="og:type" content="article">
    <meta property="og:title" content="On the Subject of Interface Hygiene">
    <meta property="article:published_time" content="2019-07-01T20:22:48-07:00"><meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@daniel_duan">
    <meta name="twitter:creator" content="@Daniel Duan">
    <meta name="apple-mobile-web-app-title" content="Daniel Duan">
    <title>On the Subject of Interface Hygiene</title>
    <link rel="alternate" type="application/rss+xml" title="Daniel Duan's Website" href="/feed.xml">
    <link rel="canonical" href="https://duan.ca/2019/07/01/combine-hygiene/">
    <link rel="stylesheet" href="/styles.css"></link>
    <link rel="shortcut icon" href="/favicon.ico">
</head>
<body><article>
    <h1>On the Subject of Interface Hygiene</h1>
    <nav>
        <p class="metainfo article-meta">
            <a href="/articles">Daniel Duan</a>
            ·
            <time datetime="2019-07-01T20:22:48-07:00" itemProp="datePublished">2019-07-01</time>
        </p>
    </nav><p>In a purly reactive world, your entire program merge into a single stream. Now,
close your eyes, and envision: your project as one, beautiful, stream.</p>
<p>Now open your eyes. Yeah, it's not. Your project is a Mac or iOS app. It's full
of your memories, sweat, and blood. And you are ready to sweat and bleed some
more by putting some Combine and SwiftUI into it. You watched the WWDC19
sessions and learned that &quot;Subjcets are super powerful&quot;. You looked into your
code and realized you can't really do anything with Combine without <code>Subject</code>s
at the current state of the project.</p>
<p>Well…</p>
<p>Here are a few habits that help keeping your project that prevasively uses
<code>Combine.Subject</code> <em>sane</em>. They should seem obvious to anyone who understands
Murphy's law and the value of minialism in interfaces. If you already are using
some reactive stream implementation, substitute the types with their
counterparts in your framework and these rules should seem down right <strong>basic</strong>.</p>
<h2>Vend <code>Subject</code>s as <code>Publisher</code>s</h2>
<p><code>Subject</code>s help bridge from the imperitive to the reactive world. Somewhat
paradoxically, sharing them is not very &quot;RX-y&quot;. This is akin to prefering <code>let</code>s
over <code>var</code>.</p>
<p>Most of the time, what you want to share is the values pumped into the stream,
not the privilage to mutate it. Because Subjects conform to <code>Publisher</code>, it's
easy to hide from the users the fact that your stream is backed by them.</p>
<pre><code class="language-swift">// Bad: now anyone who get a hold of it can mess with your stream!
public enum GreatInts {
    public var updates = CurrentValueSubject&lt;Int, Never&gt;(0)
}
</code></pre>
<p>With Combine this conversion happens via type-erasure:</p>
<pre><code class="language-swift">// Better: all your users care is the stream (publisher), so give them that!
public enum GreatInts {
    // Internally, it's backed by a subject.
    var subject = CurrentValueSubject&lt;Int, Never&gt;(0)
    // Externally, it's just a Publisher. 
    public var subject: AnyPublisher&lt;Int, Never&gt; {
        subject.eraseToAnyPublisher()
    }
}
</code></pre>
<h2>CurrentValueSubject natually caches the latest value</h2>
<p>RX theorists will hate this: sometimes it's just practical to expose
a synchronous interface to the latest vaule in the stream!</p>
<p>Two things.</p>
<ol>
<li>It might be tempting to expose the subject and let your user use its
<code>.value</code>. Well, you shouldn't (as explained in the previous section).
A separate interface dedicated to the latest value prevents people from
polluting your stream.</li>
</ol>
<pre><code class="language-swift">// (Still) bad
public final class GreatInts {
    public var updates = CurrentValueSubject&lt;Int, Never&gt;(0)
}
</code></pre>
<ol start="2">
<li>Remember <code>CurrentValueSubject</code> has that <code>.value</code> property! It may seem
surprising, but I've seen folks transitioning to RX clinging to the old ways:</li>
</ol>
<pre><code class="language-swift">public final class GreatInts {
    // well, at least it's not a public subject...
    var subject = CurrentValueSubject&lt;Int, Never&gt;(0) // &lt;- initial value 0
    public var updates: AnyPublisher&lt;Int, Never&gt; {
        subject.eraseToAnyPublisher()
    }

    // Wait, there's that 0 again
    public var latest: Int = 0 {
        didSet {
            subject.send(latest) // ?
        }
    }
}
</code></pre>
<p>First, you'll notice that <code>0</code>, the initial value, is duplicated as both the
subject's initial value, as well as the value of a stored property. And these
duplicated sources of truth persist throughout the parent's life time. Weird,
right?</p>
<p>Here's a slightly better version:</p>
<pre><code class="language-swift">public final class GreatInts {
    var subject = PassthroughSubject&lt;Int, Never&gt;()
    public var updates: AnyPublisher&lt;Int, Never&gt; {
        subject.eraseToAnyPublisher()
    }

    public var latest: Int = 0 {
        didSet {
            subject.send(latest) // ?
        }
    }
}
</code></pre>
<p>Now there's no two copy of the latest value in memory anymore. But in my opinion
it does not embrace the full power of Combine. Here's the most natual way to do
this:</p>
<pre><code class="language-swift">public final class GreatInts {
    /// This is a CurrentValueSubject again.
    var subject = CurrentValueSubject&lt;Int, Never&gt;(0)
    public var updates: AnyPublisher&lt;Int, Never&gt; {
        subject.eraseToAnyPublisher()
    }

    public var latest: Int {
        subject.value
    }
}
</code></pre>
<p>Essentially, you create separate public interface, each vends a little piece of
<code>CurrentValueSubject</code>'s power.</p>
<h2>No really, don't use <code>Subject</code>s</h2>
<p>Even a well-scoped <code>Subject</code> (properly being private or internal, depending on
your tool of choice for access control) still has a mutable state that you
probably don't want: its stream can go from &quot;alive&quot; to &quot;complete&quot;. And, again,
anyone with access can make this state transition happen, leaving you in the
undefensible position of … hoping everyone on your team to not misuse your
stuff?</p>
<p>Lucky for you (and me), a &quot;incompletable&quot; subject is a established concept -- a
&quot;Relay&quot;. I've put together a repo for you to look and/or use:</p>
<p><a href="https://github.com/dduan/relay">https://github.com/dduan/relay</a></p>
<p>Yeah, ban all Subjects in your project with a linter. Seriously.</p>
<h2>Fin</h2>
<p>That's all for now. I'm not an expert with RX myself. Hopefully these
perspective can help you avoid some nasties.</p>

</article>
<footer>
    <hr />
    <p class="metainfo article-meta">
        <a href="/articles/">More Articles</a>
        ·
        <a href="/tag/combine/">Combine</a>
        ·
        <a href="/tag/swift/">Swift</a>
    </p>
</footer></body>
</html>