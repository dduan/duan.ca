<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About CLI</title>
        <link>https://duan.ca/tag/cli/</link>
        <atom:link href="https://duan.ca/tag/cli/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>Introducing Dye</title>
                <description>&#60;p&#62;&#60;em&#62;Recently, I got a PC. And I started writing some code on Windows for the
giggles. Naturally, I gravitate towards stuff I use on macOS and Linux when it
comes to tooling. To my delight, NeoVim, ripgrep and fzf all work out of the box
in terminal simulators, which brings us to todays main topic...&#60;/em&#62;&#60;/p&#62;
&#60;p&#62;I made a terminal coloring library for Swift that works on Windows,
&#60;a href=&#34;https://github.com/dduan/Dye/releases/tag/0.0.1&#34;&#62;Dye 0.0.1 is available now&#60;/a&#62;!&#60;/p&#62;
&#60;h2&#62;So, why?&#60;/h2&#62;
&#60;p&#62;When I started working on &#60;a href=&#34;https://github.com/dduan/tre&#34;&#62;tre&#60;/a&#62;, I search in the
Rust ecosystem for a CLI interface library that supports as many platforms as
possible. Eventually I found &#60;a href=&#34;https://github.com/BurntSushi/termcolor&#34;&#62;termcolor&#60;/a&#62; among an ocean of options. As
a result, tre, like a lot of other CLI tools (like rg) written in Rust, has
a consistent UI on Windows and Unix. This experience has brought lots of joy, as
a user of both the library, and the app. I want to pay it forward to my fellow
Swift CLI makers, and their users.&#60;/p&#62;
&#60;p&#62;Zooming out slightly, success of Swift on Windows makes Swift as a skill more
valuable. And &#60;a href=&#34;https://duan.ca/2019/01/20/kick-ass-cli-tools-in-swift/&#34;&#62;I want more CLI tools written in Swift&#60;/a&#62;. So it&#39;s
a double-win, really.&#60;/p&#62;
&#60;p&#62;Lastly, it&#39;s a small library, all things considered. Being able to get it to
a shippable state on a weekend is a key reason I decided to work on it.&#60;/p&#62;
&#60;h2&#62;Technical tidbits&#60;/h2&#62;
&#60;p&#62;I love Max Howell&#39;s &#60;a href=&#34;https://github.com/mxcl/Chalk&#34;&#62;Chalk&#60;/a&#62; library. It&#39;s a 100-line Swift file that
implements &#60;a href=&#34;https://en.wikipedia.org/wiki/ANSI_escape_code&#34;&#62;ANSI escape code&#60;/a&#62; with Swift&#39;s custom string interpolation
API. It demonstrates well how simple it is to customize your terminal output.&#60;/p&#62;
&#60;p&#62;Enter Windows, where ANSI sequences are ignored by built-in terminal simulators
from the past. The console is customized via a entirely separate, stateful,
imperative APIs (Newer simulators such as the freshly released &#60;a href=&#34;&#34;&#62;Terminal&#60;/a&#62;
actually supports ANSI codes pretty well). This is our lowest common API
denominator, which ultimately dictated the design of Dye.&#60;/p&#62;
&#60;p&#62;Dye&#39;s API is centered around Swift&#39;s built-in protocol &#60;code&#62;TextOutputStream&#60;/code&#62;. You
create a stream object and mutate the style need for upcoming output:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;let output = OutputStream.standardOutput()
output.color.foreground = .blue
print(&#38;quot;blue text&#38;quot;, to &#38;amp;stream) // blue text is blue
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;If the stream is redirected to something other than the terminal, styling gets
automatically disabled. There are various options to customize this behavior.&#60;/p&#62;
&#60;p&#62;Take a look at this &#60;a href=&#34;https://github.com/dduan/Dye/blob/master/Examples/main.swift&#34;&#62;sample app&#60;/a&#62; to get a more concrete picture of
how things work.&#60;/p&#62;
&#60;hr /&#62;
&#60;p&#62;I&#39;ll end with a screenshot of the sample app running in Command Prompt:&#60;/p&#62;
&#60;p&#62;&#60;img src=&#34;/assets/2020/06/01/windows-example-screenshot.jpg&#34; alt=&#34;Dye sample app running in Windows Command Prompt&#34; /&#62;&#60;/p&#62;
&#60;p&#62;Let&#39;s build more.&#60;/p&#62;
</description>
                <pubDate>Mon, 01 Jun 2020 15:08:01 -0700</pubDate>
                <link>https://duan.ca/2020/06/01/dye/</link>
                <guid isPermaLink="true">https://duan.ca/2020/06/01/dye/</guid>
            </item>
            <item>
                <title>Kick-ass CLI Tools In Swift</title>
                <description>&#60;p&#62;As someone who lives in a terminal simulator, I&#39;m pleasantly surprised by the
new toys we get in recent years such as &#60;a href=&#34;https://github.com/junegunn/fzf&#34;&#62;fzf&#60;/a&#62;, &#60;a href=&#34;https://github.com/BurntSushi/ripgrep&#34;&#62;ripgrep&#60;/a&#62;, &#60;a href=&#34;https://github.com/sharkdp/fd&#34;&#62;fd&#60;/a&#62;, etc.
A great number of these are written in relatively young programming languages
such as Go and Rust. But, noticibly, none of them are written in Swift.&#60;/p&#62;
&#60;p&#62;In this post, I&#39;ll try to explain why that is.&#60;/p&#62;
&#60;h2&#62;POSIX Ergonomics&#60;/h2&#62;
&#60;p&#62;Unix-like virtual file systems has been around for decades. API that manupulates
such systems has standardized a long time ago and exists in most computers
running Linux/BSD/macOS today (and, to a large extend, smart phones). To Swift
users, Using these APIs is straight-forward (&#60;code&#62;rmdir(&#38;quot;path/to/dir&#38;quot;)&#60;/code&#62;).&#60;/p&#62;
&#60;p&#62;So Swift programmers are all happy campers (re-)inventeing all sorts of file
system utilities, right?&#60;/p&#62;
&#60;p&#62;Well, not quite.&#60;/p&#62;
&#60;p&#62;Okay, I lied about POSIX APIs being &#38;quot;straight-forward&#38;quot; in Swift. Or rather, this
is very subjective.&#60;/p&#62;
&#60;p&#62;Continuing with the &#60;code&#62;rmdir&#60;/code&#62; example, we must first import it from either &#60;code&#62;Glibc&#60;/code&#62;
or &#60;code&#62;Darwin&#60;/code&#62;, depending on your OS. To know whether the operation is successful,
we need to see whether it returned integer 0. To learn &#60;em&#62;why&#60;/em&#62; 0 was not returned,
we need to read the &#38;quot;magical&#38;quot; variable &#60;code&#62;errno&#60;/code&#62;. &#60;code&#62;errno&#60;/code&#62; could be written to by
other APIs so we&#39;d better capture it in timeâ€¦&#60;/p&#62;
&#60;p&#62;And that&#39;s one of the simpler APIs in POSIX calls!&#60;/p&#62;
&#60;p&#62;Programmers whine about ergonomics partially because we are previlidged and
spoiled. But mostly because our attention is a limited resources. Mixing API
conventions distracts us from solving the problem at hand. Bad ergonomics,
therefore, drives away a good potion of users who cares about quality of their
tools.&#60;/p&#62;
&#60;h2&#62;Culture and History&#60;/h2&#62;
&#60;p&#62;As of this writing, the release of Swift 5 is imminent. The vast majority of
existing Swift code is written to run on iOS. The concept of a file, or the
traditional virtal file system, is hidden to iOS users, and sandboxed for
developers. I bet most Swift users rarely think about the fact that there&#39;s
a entire set of POSIX API at their disposal.&#60;/p&#62;
&#60;p&#62;&#60;code&#62;Foundation&#60;/code&#62; alleviates the need to deal with files and directories: &#60;code&#62;Bundle&#60;/code&#62;
locates the files; &#60;code&#62;CoreData&#60;/code&#62;, &#60;code&#62;UserDefaults&#60;/code&#62; or the keychain is your primary
way to persist data; &#60;code&#62;Data&#60;/code&#62;, &#60;code&#62;String&#60;/code&#62; or &#60;code&#62;NSCoding&#60;/code&#62; has methods to read and
write to files.  And finally, if you really need to deal with files,
&#60;code&#62;NSFileManager&#60;/code&#62; has everything you&#39;ll ever need.&#60;/p&#62;
&#60;p&#62;Why would a productive Swift programmer think about POSIX in this environment?
Why would a tutor teach POSIX over the useful/practical/&#38;quot;native&#38;quot; alternatives?&#60;/p&#62;
&#60;p&#62;We can trace &#38;quot;riding on the Apple platform&#38;quot; mentality back to the pre-iPhone
days, where a very small Mac developer community labors on on a niche platform
(compared to iOS today) and they &#60;em&#62;loved&#60;/em&#62; it. However, I&#39;m sure they used more
POSIX stuff back then than the average iOS developers today.&#60;/p&#62;
&#60;p&#62;Having a great library such as Foundation on the most popular developer
platform where the language thrives means it&#39;ll take longer for &#38;quot;subcultures&#38;quot;
to emerge, if they do at all.&#60;/p&#62;
&#60;h2&#62;The Standard Library And Its Influence on New Users&#60;/h2&#62;
&#60;p&#62;File system APIs being in &#60;code&#62;Foundation&#60;/code&#62; as opposed to the standard library is
probably a temporary condition. Nevertheless, it has at least the following
implications:&#60;/p&#62;
&#60;ol&#62;
&#60;li&#62;
&#60;p&#62;Its quality of implementation is not held on the same standard that those
APIs in the standard library. This is especially true for the separate,
open-source &#60;code&#62;Foundation&#60;/code&#62; implementation. Getting consistent and correct
behaviors across macOS and Linux is hard.&#60;/p&#62;
&#60;/li&#62;
&#60;li&#62;
&#60;p&#62;A person learning Swift won&#39;t explore the language with a file system API.
This I suspect, is &#60;strong&#62;the most important reason many of these great CLI
utilites are written in other programming languages&#60;/strong&#62;. Programmers seek
instant gratification when they learn. And they usually stay in a limited
domain (like iOS) at first. This is where the built-in library is special: no
matter which domain is chosen, it&#39;s always available. Languages such as Go
and Rust include things like paths and files in their built-in library.
Playing with these APIs while learning the lanugage plants a seed for future,
serious, projects. There are less users of these languages compared to Swift,
but there are more people thinking about projects that involves file systems
in thoes communities. (Note I don&#39;t have statistics here, just a guess.)&#60;/p&#62;
&#60;/li&#62;
&#60;/ol&#62;
&#60;h2&#62;Conclusion&#60;/h2&#62;
&#60;p&#62;The next killer CLI tool is still more likely to be written in Go or Rust,
than in Swift. Hopefully, somewhere in these speculations is a true cause of
this phenomena. Maybe someone reading this will be inspired to accelerate change
that will eventually revert the condition. (I&#39;m &#60;a href=&#34;https://github.com/dduan/Pathos&#34;&#62;trying&#60;/a&#62;).&#60;/p&#62;
</description>
                <pubDate>Sun, 20 Jan 2019 16:09:38 -0800</pubDate>
                <link>https://duan.ca/2019/01/20/kick-ass-cli-tools-in-swift/</link>
                <guid isPermaLink="true">https://duan.ca/2019/01/20/kick-ass-cli-tools-in-swift/</guid>
            </item>
    </channel>
</rss>