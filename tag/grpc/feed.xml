<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About GRPC</title>
        <link>https://duan.ca/tag/grpc/</link>
        <atom:link href="https://duan.ca/tag/grpc/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>GRPC Status With Error Details in Swift</title>
                <description>&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In GRPC, one could define an RPC that, in addition to the normal
request-response messages, it also defines a custom message to represent errors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-proto&quot;&gt;message SignUpWithEmailRequest {
  string email = 1;
  string password = 2;
  string referral_code = 3;
}

message SignUpWithEmailResponse {
  AccessTokenDTO token = 1;
}

message SignUpWithEmailErrorResponse {
  enum Kind {
    KIND_UNKNOWN = 0;
    KIND_EMAIL_ALREADY_REGISTERED = 1;
    KIND_INVALID_PASSWORD = 2;
    KIND_INVALID_EMAIL = 3;
    KIND_INVALID_CODE = 4;
  }

  Kind kind = 1;
  repeated string reasons = 2;
}

service AuthenticationService {
  rpc SignUpWithEmail(SignUpWithEmailRequest) returns (SignUpWithEmailResponse) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... in this example, &lt;code&gt;SignUpWithEmailErrorResponse&lt;/code&gt; is not directly referenced
in by &lt;code&gt;AuthenticationService&lt;/code&gt;. But a server can use it as GRPC status with
details. In Go the code might look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;import (
	&amp;quot;google.golang.org/grpc/codes&amp;quot;
	&amp;quot;google.golang.org/grpc/status&amp;quot;
)

// ...

_, err = queries.GetUserByEmail(ctx, email)
if err == nil {
    response := &amp;amp;SignUpWithEmailErrorResponse{
        Kind:    SignUpWithEmailErrorResponse_KIND_EMAIL_ALREADY_REGISTERED,
        Reasons: []string{},
    }

    st := status.New(codes.AlreadyExists, &amp;quot;Email already registered&amp;quot;)
    stWithDetails, err := st.WithDetails(response)
    if err != nil {
        return nil, err
    }

    return nil, stWithDetails.Err()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is all very type-safe, very demure, until you realize that in grpc-swift
1.X there&#x27;s no API to retrieve this &amp;quot;status with detail&amp;quot;. When the information
is transimitted over the wire, you will have to dig it out manually. In this
post, I&#x27;ll document how I did this with a client-side interceptor.&lt;/p&gt;
&lt;h2&gt;The Swift interceptor&lt;/h2&gt;
&lt;p&gt;In Swift, when you make the RPC request, you&#x27;ll get a standard error code and
error message if the server returns an error with the code shown earlier:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;// Use the generated client code to make the gRPC request
var request = SignUpWithEmailRequest()
request.email = // ...
request.password = // ...
request.referralCode = // ...
do {
    let response = try await client.signUpWithEmail(request)
} catch {
    guard let error = error as? GRPCStatus else {
        print(&amp;quot;Error: \(error)&amp;quot;)
        return
    }
    print(error.code) // AlreadyExists
    print(error.message) // &amp;quot;Email already registered&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But, you, being a responsible client developer/tech lead/CTO, want to use the
type-safe enum from the protobuf definition so that you can display the error in
the right context, or perhaps localize it properly.&lt;/p&gt;
&lt;p&gt;Here&#x27;s the big picture: there may be many such custom RPC error types. Our
solution should be universal, and flexible to handle each of them. Enter
interceptors! I mean, chances are, you know about them because you are working
with gRPC. Let&#x27;s write one to get our type-safe status details. Starting with
a custom receive method, for the &amp;quot;.end&amp;quot; part of the response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;final class GRPCErrorDetailsInterceptor&amp;lt;Request, Response&amp;gt;:
  ClientInterceptor&amp;lt;Request, Response&amp;gt;, @unchecked Sendable
{
  override func receive(
    _ part: GRPCClientResponsePart&amp;lt;Response&amp;gt;,
    context: ClientInterceptorContext&amp;lt;Request, Response&amp;gt;
  ) {
    switch part {
    case .end(var status, let headers):
      // extract the error details, and forward it.
    default:
      context.receive(part)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... the &amp;quot;end&amp;quot; part contains the error status, as well as some trailing metadata.
The metadata includes our status details under the key &lt;code&gt;grpc-status-details-bin&lt;/code&gt;.
It&#x27;s base64 encoded, so we&#x27;ll need to decode it...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;switch part {
case .end(var status, let headers):
    guard
        // grab the status details
        let statusDetails = headers[&amp;quot;grpc-status-details-bin&amp;quot;].first,
        // decode to data
        let data = Data(base64Encoded: statusDetails),
    // ...
default:
  context.receive(part)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, with some experience with GRPC in Swift, you might think it&#x27;s
time to instantiate your custom error type with &lt;code&gt;.init(seralizedData:)&lt;/code&gt;. But
there&#x27;d be 2 problems:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;You don&#x27;t want each custom types from protobuf to make an appearance in an
interceptor.&lt;/li&gt;
&lt;li&gt;This data would not be in the right shape, despite what the metadata key
says.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In fact, the data is of the well-known type &lt;code&gt;Google_Rpc_Status&lt;/code&gt;. And our stutus
details, well, one its &lt;code&gt;.details&lt;/code&gt; element. So:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;switch part {
case .end(var status, let headers):
    guard
        let statusDetails = headers[&amp;quot;grpc-status-details-bin&amp;quot;].first,
        let data = Data(base64Encoded: statusDetails),
        // the data, despite being under &amp;quot;grpc-status-details-bin&amp;quot;, is
        // indeed not the status detail, but the statu itself:
        let googleStatus = try? Google_Rpc_Status(serializedData: data)
        // and the `details` field contains the actual status detail:
        let details = googleStatus.details.first,
    else {
        context.receive(part)
        break
    }
    // ...
default:
  context.receive(part)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... &lt;code&gt;details&lt;/code&gt; is of type &lt;code&gt;Google_Protobuf_Any&lt;/code&gt;. It is indeed a payload with the
content for &lt;code&gt;SignUpWithEmailErrorResponse&lt;/code&gt; as defined in the Protobuf. One
question remains: how do we pass it from our intereceptor to the RPC call site?&lt;/p&gt;
&lt;p&gt;Look at the call site from earlier: we have 2 code paths. If the call succeeds,
we get a &lt;code&gt;SignUpWithEmailResponse&lt;/code&gt;. If it fails, we get a &lt;code&gt;GRPCStatus&lt;/code&gt; as the
thrown error. Lucky for us, &lt;code&gt;GRPCStatus&lt;/code&gt; has an unused field, &lt;code&gt;cause&lt;/code&gt;. In my
version of &lt;code&gt;grpc-swift&lt;/code&gt;, the field has the following docstring:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;/// The cause of an error (not &#x27;ok&#x27;) status. This value is never transmitted
/// over the wire and is **not** included in equality checks.
public var cause: Error? { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It seems like a perfect vessel for our status details!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;switch part {
case .end(var status, let headers):
    guard
        let statusDetails = headers[&amp;quot;grpc-status-details-bin&amp;quot;].first,
        let data = Data(base64Encoded: statusDetails),
        let googleStatus = try? Google_Rpc_Status(serializedData: data)
        let details = googleStatus.details.first,
    else {
        context.receive(part)
        break
    }
    // isn&#x27;t it convenient that we declared `status` as a `var` ealier ðŸ˜‰?
    status.cause = details
    // forward to the caller, yay!
    context.receive(.end(status, headers))
default:
  context.receive(part)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now our client will get the details of type &lt;code&gt;Google_Protobuf_Any&lt;/code&gt; from the
&lt;code&gt;.cause&lt;/code&gt; field of the thrown error. The client can proceed to decode it using
the protobuf-generated specific type with its built-in &lt;code&gt;.init(decodingAny:)&lt;/code&gt;
initializer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;// Use the generated client code to make the gRPC request
var request = SignUpWithEmailRequest()
request.email = // ...
request.password = // ...
request.referralCode = // ...
do {
    let response = try await client.signUpWithEmail(request)
} catch {
    guard let error = error as? GRPCStatus else {
        print(&amp;quot;Error: \(error)&amp;quot;)
        return
    }

    // let&#x27;s be type-safe, finally!
    guard
        let details = error.cause as? Google_Protobuf_Any,
        let signUpError = try? SignUpWithEmailErrorResponse(decodingAny: details)
    else {
        print(&amp;quot;Error: \(error)&amp;quot;)
        return
    }

    // ðŸŽ‰
    switch signUpError.kind {
    // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I find this to be clean, targeted solution. Knowing the error detail&#x27;s
transmission format is key to making this work. The fact that we also got
a clean architecture from exploiting an unused field is also very cool.&lt;/p&gt;
</description>
                <pubDate>Sat, 25 Jan 2025 19:53:30 -0800</pubDate>
                <link>https://duan.ca/2025/01/25/grpc-status-with-details-in-swift/</link>
                <guid isPermaLink="true">https://duan.ca/2025/01/25/grpc-status-with-details-in-swift/</guid>
            </item>
    </channel>
</rss>