<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About Haskell</title>
        <link>https://duan.ca/tag/haskell/</link>
        <atom:link href="https://duan.ca/tag/haskell/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>Magical Interactions</title>
                <description>&#60;p&#62;I want to talk about this little function:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;func interact(_ process: (String) -&#38;gt; String) {
    var input = &#38;quot;&#38;quot;
    while let line = readLine() {
        input += line
    }

    print(process(input))
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Brief explanation: it reads all the input from stdin as a &#60;code&#62;String&#60;/code&#62;, feeds it
into a closure &#60;code&#62;process&#60;/code&#62;, which it takes in as its only argument, and prints
&#60;code&#62;process&#60;/code&#62;&#39;s output.&#60;/p&#62;
&#60;p&#62;Here&#39;s how one might use it:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;// counts characters from stdin and prints result to stdout
interact { String($0.count) }
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Got that? Well, now I&#39;m going to rewrite it in a slightly less Swift-y way:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;let count: (String) -&#38;gt; String = {
    return String($0.count)
}

interact(count)
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;The argument for &#60;code&#62;interact&#60;/code&#62; got defined with a name and an explicit type
signature.&#60;/p&#62;
&#60;p&#62;So, what&#39;s so special about this &#60;code&#62;interact&#60;/code&#62; function? Two words: &#60;em&#62;side effects&#60;/em&#62;.
More precisely, it took away the concern of side-effects from the user. &#60;code&#62;count&#60;/code&#62;
belongs in the realm of &#60;em&#62;pure&#60;/em&#62; functions. It has no worries about file handles
or operating systems. It&#39;s &#60;code&#62;(String) -&#38;gt; String&#60;/code&#62;. I wanted to emphasize this with
the rewrite. Look at that empty line. Now you see a boundary between 2 worlds.&#60;/p&#62;
&#60;p&#62;This may all seem contrived. But when I learned about &#60;a href=&#34;http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:interact&#34;&#62;this function in
Haskell&#60;/a&#62;, I was blown away.&#60;/p&#62;
&#60;p&#62;It&#39;s like a great magic trick: you are presented a scenario, say, writing
a little script. Maybe you need to process some CLI output and print out a CSV
or JSON string (literally 90% of the script I write).  A Haskell programmer
would jump into the bottom level of the problem and start writing these little
pure functions: one to split the string, one to convert some numbers, one to
manipulate a list, one to match some patterns...gradually the broken-down
absractions get built back up via function composition. You can see the light at
the end of the tunnel, yes, yes! If you feed this list into that function that
returns a string you&#39;ll have the right value to print out!  Okay, now the
problem is solved in the pure functional world! The only thing left to do is...&#60;/p&#62;
&#60;p&#62;Now, the setup of the magic is complete. Now, you are onboard with the solution,
you thought the problem through with the magician...you are distracted. The
ending came so...quickly, but unexpected. What? You just feed your solution to
this &#60;code&#62;interact&#60;/code&#62; function and...that&#39;s it? I was expecting some &#60;code&#62;readLine&#60;/code&#62;s or
&#60;code&#62;print&#60;/code&#62;s (okay, at least 1 &#60;code&#62;print&#60;/code&#62; statement)!&#60;/p&#62;
&#60;p&#62;That&#39;s the thing: &#60;code&#62;interact&#60;/code&#62; deals with &#60;em&#62;two&#60;/em&#62; side effects, the input and the
output. But its user deals with &#60;em&#62;zero&#60;/em&#62;. It&#39;s as if the two effects &#38;quot;cancel&#38;quot; each
other out! It&#39;s a &#60;em&#62;neat&#60;/em&#62; trick, really. Small, low-key, easy to miss. But I&#39;m
glad I noticed it and come to appreciate its power and simplicity.&#60;/p&#62;
</description>
                <pubDate>Sat, 01 Sep 2018 11:08:57 -0700</pubDate>
                <link>https://duan.ca/2018/09/01/magical-interaction/</link>
                <guid isPermaLink="true">https://duan.ca/2018/09/01/magical-interaction/</guid>
            </item>
            <item>
                <title>List Comprehension In Swift</title>
                <description>&#60;p&#62;Let&#39;s explore ways to add list comprehension to Swift.&#60;/p&#62;
&#60;h2&#62;Motivation&#60;/h2&#62;
&#60;p&#62;&#60;a href=&#34;https://en.wikipedia.org/wiki/List_comprehension&#34;&#62;List comprehension&#60;/a&#62; should be no stranger to a Python or (and?) Haskell user. It&#39;s a really compact syntax
that deals with &#60;a href=&#34;https://en.wikipedia.org/wiki/Cartesian_product&#34;&#62;Cartesian product&#60;/a&#62; of lists. In the case of Python, it&#39;s probably responsible for the lack
of evolution of lambda expressions, since it&#39;s much nicer to write one-liners with it in place of &#60;code&#62;map&#60;/code&#62;s and
&#60;code&#62;filter&#60;/code&#62;s.&#60;/p&#62;
&#60;p&#62;Here&#39;s an example of an list comprehension in Haskell from Wikipedia:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-haskell&#34;&#62;a = [(x,y) | x &#38;lt;- [1..5], y &#38;lt;- [3..5]]
-- [(1,3),(1,4),(1,5),(2,3),(2,4) ...
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;In this example, a list of pair of integers is constructed from 2 lists of integers.&#60;/p&#62;
&#60;p&#62;Here is what that example would be in Python:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-python&#34;&#62;a = [(x, y) for x in range(1,6) for y in range(3, 6)]
# [(1, 3), (1, 4), (1, 5), (2, 3), (2, 4) ...
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Here&#39;s what it would be in mathematics (except we are dealing with sets, not lists, but I&#39;ll only refer to
lists from here on.):&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;Let (a, b) be an ordered list of elements

{(x, y)|x ∈ {1,2,3,4,5}, y ∈ {3,4,5}}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;One can filter out unwanted elements with predicates, and apply arbitrary functions to elements of the
result. Let&#39;s say we only want even numbers from the first list, and we want the sum of x and y, continuing on
our examples:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-haskell&#34;&#62;a = [x+y | x &#38;lt;- [1..5], y &#38;lt;- [3..5], x `mod` 2 == 0]
&#60;/code&#62;&#60;/pre&#62;
&#60;pre&#62;&#60;code class=&#34;language-python&#34;&#62;a = [x + y for x in range(1,6) for y in range(3, 6) if x % 2 == 0]
&#60;/code&#62;&#60;/pre&#62;
&#60;pre&#62;&#60;code&#62;{x+y|x ∈ {1,2,3,4,5}, y ∈ {3,4,5}, x is even}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;In theory, this syntax can be applied to an arbitrary number of lists. Putting aside how often this need comes
up in day-to-day programming in your domain, it should be obvious that it&#39;s alternative, be it nested loops or
&#60;code&#62;map&#60;/code&#62;s and &#60;code&#62;filter&#60;/code&#62;s, is pretty clumsy in comparison.&#60;/p&#62;
&#60;h2&#62;Adding List Comprehension in Swift&#60;/h2&#62;
&#60;p&#62;A comprehension can be considered in 3 parts:&#60;/p&#62;
&#60;ol&#62;
&#60;li&#62;some lists, each may contain a different type of elements.&#60;/li&#62;
&#60;li&#62;a predicate (or a series of them joined logically) to filter out elements.&#60;/li&#62;
&#60;li&#62;a function to process the combination of elements into results.&#60;/li&#62;
&#60;/ol&#62;
&#60;p&#62;In Swift, if our input is only one list, there&#39;s a pretty sweet way to achieve that:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;list.filter(predicate).map(processor)
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;To make comprehension work with more lists, we have some syntax options.&#60;/p&#62;
&#60;h3&#62;Option One&#60;/h3&#62;
&#60;p&#62;The &#38;quot;brute force&#38;quot; option would be a function that parameterize all 3 parts of the comprehension. Such as&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;// going with order of appearance in Python/Haskell syntax
func comprehension&#38;lt;Element, List, Result&#38;gt;(
    predicate: (Element) -&#38;gt; Bool,
    list: List,
    processor: (Element) -&#38;gt; Result
) where
    List: Sequence, List.Element == Element

{
    // implementation
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;To supporting more than one list, just add more parameters to both types and the function itself.&#60;/p&#62;
&#60;p&#62;(Can&#39;t wait until we can have &#60;a href=&#34;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#variadic-generics&#34;&#62;variadic generic parameters&#60;/a&#62;!)&#60;/p&#62;
&#60;h3&#62;Option Two&#60;/h3&#62;
&#60;p&#62;Deploy more syntax tricks. Somehow make it visually similar to the math/Haskell/Python notation. If we can
accept some temporary data structure and introduce/implement some operators, there&#39;d be many possibilities.&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;/// Just an example of the infinite possibilities.
processor | list0 &#38;amp;&#38;amp;&#38;amp; list1 | predicate
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;I&#39;ll leave the implementation of this example as an exercise to the reader.&#60;/p&#62;
&#60;h3&#62;Option That I Like&#60;/h3&#62;
&#60;p&#62;I spent quite some time exploring the realm of possibilities in &#38;quot;option two&#38;quot;. However, introducing data
structures and custom operators just to do what &#38;quot;option one&#38;quot; offers seems really unappealing. It&#39;s not
entirely clear that doing so would be &#38;quot;Swift-y&#38;quot; anyways! Eventually, I did find an arrangement that fits in
Swift, and requires no fancy syntax trickery.&#60;/p&#62;
&#60;p&#62;The result of list comprehension is a list. The goal of this operation is to &#60;em&#62;construct&#60;/em&#62; a list. Yep, thinking
along this line, it became obvious that using a &#38;quot;list&#38;quot;&#39;s initializer is just natural:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;let a = Array(1..&#38;lt;5, 3..&#38;lt;5, where: { n, _ in n % 2 == 0 }) { ($0, $1) }
// [(2,3),(2,4),(2,5) ...
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;The processing function is at the end to take advantage of the trailing closure syntax. It&#39;s nicer when
there&#39;s not predicate:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;let a = Array(1..&#38;lt;5, 3..&#38;lt;5) { ($0, $1) }
// [(1,3),(1,4),(1,5),(2,3),(2,4) ...
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;This syntax seems both succinct and Swift-y.&#60;/p&#62;
&#60;p&#62;I put an implementation on &#60;a href=&#34;https://github.com/dduan/Comprehension&#34;&#62;github&#60;/a&#62;, in case you find it useful.&#60;/p&#62;
&#60;h2&#62;Parting Thoughts&#60;/h2&#62;
&#60;p&#62;There&#39;s no doubt that the conclusion in this post is imperfect. Though it feels more Swift-y, it deviates from
the mathematical syntax by a lot. We can only implement it for finite number of lists. When many lists are
involved, using a embedded closure as the predicate would make the compiler complain that the expression is
too complex. We suffer from the normal woes with Swift closures where anonymous arguments (&#60;code&#62;$0&#60;/code&#62;, &#60;code&#62;$1&#60;/code&#62;, etc)
won&#39;t work unless the last one is mentioned in the closure&#39;s body. Overloading &#60;code&#62;Array&#60;/code&#62; initializer may
negatively affect compilation speed in large projects.&#60;/p&#62;
&#60;p&#62;Not all of these issues are temporary.&#60;/p&#62;
&#60;p&#62;Does list comprehension warrant a language change in Swift? Can you think of better ways to implement it
with the current compiler?&#60;/p&#62;
</description>
                <pubDate>Sat, 09 Dec 2017 12:26:30 -0800</pubDate>
                <link>https://duan.ca/2017/12/09/list-comprehension-in-swift/</link>
                <guid isPermaLink="true">https://duan.ca/2017/12/09/list-comprehension-in-swift/</guid>
            </item>
    </channel>
</rss>