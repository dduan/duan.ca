<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About Make</title>
        <link>https://duan.ca/tag/make/</link>
        <atom:link href="https://duan.ca/tag/make/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>Distribution Tests</title>
                <description>&#60;p&#62;There are several ways to build dependencies for a Swift 3 project:
Swift Package Manager, Cocoapods, Carthage, etc. Many have an opinion on which
is the best choice for their projects. As a library author who want to help as
many people as possible, however, they can&#39;t ignore any of them.&#60;/p&#62;
&#60;p&#62;I sometimes question the sanity of that conclusion: instead of becoming an
export in each package manager, I find myself a novice of all. Did I break
support for any of them with this project change? Is it still working on
a particular platform, say, tvOS? Can I &#60;em&#62;really&#60;/em&#62; know?&#60;/p&#62;
&#60;p&#62;The only way to &#60;em&#62;really&#60;/em&#62; know is to verify yourself: both Cocoapods and
Carthage support four platforms -- iOS, macOS, watchOS, tvOS; Swift Package
Manager only works on Mac or Linux. So that&#39;s 2*4+1=9 targets. All these
targets need is have the library in question fetched and imported. Every Swift
library author should have such verification before publishing updates of
their project.&#60;/p&#62;
&#60;p&#62;The steps to verify can be triggered with commands: fetch and build
dependencies, build Xcode/Swift project. To automate the process, put these
commands in a script or a Makefile. But wait, there&#39;s more! One shouldn&#39;t have
to create these dummy projects every time they create a new library. If all
these projects do is importing a library and attempt to build, they should
work for &#60;em&#62;any&#60;/em&#62; library. The config in &#60;code&#62;Package.swift&#60;/code&#62;/&#60;code&#62;Cocoapods&#60;/code&#62;/&#60;code&#62;Cartfile&#60;/code&#62;
and the &#60;code&#62;import&#60;/code&#62; statements just needs some strings replaced: name of the next
library, URL for its git repository, etc. And that&#39;s a scriptable process as
well!&#60;/p&#62;
&#60;p&#62;To recap, one could, in theory, copy in some dummy projects, run a command to
inject information about a new library, run another command to build all these
project, verifying that support for those package managers remain functional.&#60;/p&#62;
&#60;p&#62;In reality, I have created &#60;a href=&#34;https://github.com/dduan/DistributionTests&#34;&#62;DistributionTests&#60;/a&#62; and put it
on &#60;a href=&#34;https://github.com/dduan/DistributionTests&#34;&#62;Github&#60;/a&#62; ðŸ˜‰.&#60;/p&#62;
&#60;p&#62;The script &#60;code&#62;customize&#60;/code&#62; requires 3 pieces of information of the library: its
import name, its git repository URL and a major version number. The assumption
here is the library generates uniformly named artifacts: the file name for
&#60;code&#62;.framework&#60;/code&#62; and the name users use to import it are the same. Testing
distribution of a library is as simple as:&#60;/p&#62;
&#60;ol&#62;
&#60;li&#62;clone the project.&#60;/li&#62;
&#60;li&#62;customize the project with &#60;code&#62;customize&#60;/code&#62;.&#60;/li&#62;
&#60;li&#62;run &#60;code&#62;make&#60;/code&#62;.&#60;/li&#62;
&#60;/ol&#62;
&#60;p&#62;If you do step 1 and 2, include the projects in library&#39;s repository, then
only step 3 is necessary! This makes testing distribution methods trivial on
a continuous integration server.&#60;/p&#62;
&#60;p&#62;Go forth and create fearlessly!&#60;/p&#62;
</description>
                <pubDate>Mon, 10 Oct 2016 10:34:49 -0700</pubDate>
                <link>https://duan.ca/2016/10/10/distribution-tests/</link>
                <guid isPermaLink="true">https://duan.ca/2016/10/10/distribution-tests/</guid>
            </item>
            <item>
                <title>Deploy Jekyll Site To Github With Make</title>
                <description>&#60;p&#62;At risks of being too meta, I want to talk about how this post is going to go
from my computer to a repository on Github on both the &#60;code&#62;master&#60;/code&#62; and &#60;code&#62;gh-pages&#60;/code&#62;
branch. The former contains the file I&#39;m typing, and the latter an updated
HTML site generated by Jekyll.&#60;/p&#62;
&#60;p&#62;Here&#39;s how: I type &#60;code&#62;make deploy&#60;/code&#62; once I commit this file in my local
repository.&#60;/p&#62;
&#60;p&#62;I spent a day to set up a Jekyll site. The last part involves deploying it to
Github, my preferred way to host a static site. There are a lot of posts and
scripts on how to achieve it. And Github seems to have an &#38;quot;afficial&#38;quot; support
for Jekyll site that disables plugin scripts (understandably so).&#60;/p&#62;
&#60;p&#62;But having worked with git and make for all these years made me immune to all
the fanciness the Internet tries to sell.&#60;/p&#62;
&#60;p&#62;Here&#39;s my script for deploying a Jekyll project to Github pages:&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;DEPLOY_PATH=/tmp/jekyll_deploy
build:
	jekyll build

deploy:
	git checkout -f gh-pages
	git clean -d -x -f
	git pull
	git checkout master
	jekyll build
	rm -rf ${DEPLOY_PATH}
	mkdir ${DEPLOY_PATH}
	cp -R .git ${DEPLOY_PATH}
	cd ${DEPLOY_PATH}; git checkout gh-pages; git clean -d -x -f
	cp -R _site/* ${DEPLOY_PATH}
	cd ${DEPLOY_PATH}; git add .; git commit -m &#38;quot;`curl whatthecommit.com/index.txt`&#38;quot;
	cd ${DEPLOY_PATH}; git push -f origin gh-pages
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Drop it into root of your Jekyll project, commit all changes (including the
&#60;code&#62;Makefile&#60;/code&#62;). And type &#60;code&#62;make deploy&#60;/code&#62;. BOOM, done.&#60;/p&#62;
&#60;p&#62;There are a couple of assumptions:&#60;/p&#62;
&#60;ul&#62;
&#60;li&#62;You build the site in the &#60;code&#62;_site&#60;/code&#62; folder&#60;/li&#62;
&#60;li&#62;You store Jekyll source on &#60;code&#62;master&#60;/code&#62; and have the &#60;code&#62;gh-pages&#60;/code&#62; branch up.&#60;/li&#62;
&#60;li&#62;You can build the site by running &#60;code&#62;jekyll build&#60;/code&#62;.&#60;/li&#62;
&#60;li&#62;You don&#39;t care about commit message on the deploy branch.&#60;/li&#62;
&#60;/ul&#62;
&#60;p&#62;I like it better than other methods because it does not require installing
additional software/scripts and there&#39;s no restriction on plugins.&#60;/p&#62;
</description>
                <pubDate>Sun, 15 May 2016 01:00:00 -0700</pubDate>
                <link>https://duan.ca/2016/05/15/deploy-jekyll-to-github/</link>
                <guid isPermaLink="true">https://duan.ca/2016/05/15/deploy-jekyll-to-github/</guid>
            </item>
    </channel>
</rss>