<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About Nix</title>
        <link>https://duan.ca/tag/nix/</link>
        <atom:link href="https://duan.ca/tag/nix/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>Flake For Non-Nix Projects</title>
                <description>&#60;p&#62;The ideal outcome of using Nix or home-manager is to have as many things as possible under their control.
Among these things are developer tools for coding. You may need &#60;code&#62;cargo&#60;/code&#62;, and &#60;code&#62;rust-analyzer&#60;/code&#62; for Rust projects;
&#60;code&#62;ipython&#60;/code&#62;, and &#60;code&#62;python-lsp-server&#60;/code&#62; for Python projects, etc.&#60;/p&#62;
&#60;p&#62;Of course, the simplest solution is to have them all installed and configured in home-manager or the OS level.
But, over time, you&#39;ll end up with a ton of stuff.&#60;/p&#62;
&#60;p&#62;Maybe that won&#39;t bother you. Fine, but this approach is at odds with some convention of the Nix community. You
see, there&#39;s this command called &#60;code&#62;nix-shell&#60;/code&#62;, or &#60;code&#62;nix develop&#60;/code&#62;, which sets up a environment with certain
packages, with the expectation that you only need them sometimes, usually within the context of developing
a certain software project.&#60;/p&#62;
&#60;p&#62;So, arguably, a better alternative to installing everything you possibly need is to keep only the essential
tools you always need, regardless of what you are working on. Things like &#60;code&#62;neovim&#60;/code&#62;, &#60;code&#62;git&#60;/code&#62;, &#60;code&#62;ripgrep&#60;/code&#62;, etc.
When a project demands things such as &#60;code&#62;rust-analyzer&#60;/code&#62;, running &#60;code&#62;nix develop&#60;/code&#62; should set it up for you.&#60;/p&#62;
&#60;p&#62;How do we implement that? In a imaginary world where every single software project is built with a flake.nix,
the &#60;code&#62;devShell&#60;/code&#62; property should provide everything the software project owner expect you to need. And you just
&#60;code&#62;cd&#60;/code&#62; into the root of the project, run &#60;code&#62;nix develop&#60;/code&#62;, and you are off to the races.&#60;/p&#62;
&#60;p&#62;Several problems:&#60;/p&#62;
&#60;ol&#62;
&#60;li&#62;running &#60;code&#62;nix develop&#60;/code&#62; is repetitive, and therefore, annoying.&#60;/li&#62;
&#60;li&#62;the owner of a flake.nix may have drastically different taste for the best dev tools for their project
(bet!).&#60;/li&#62;
&#60;li&#62;we don&#39;t live in a world built with Nix flakes.&#60;/li&#62;
&#60;/ol&#62;
&#60;p&#62;Yikes.&#60;/p&#62;
&#60;p&#62;To solve &#60;code&#62;1&#60;/code&#62;, enter &#60;a href=&#34;https://github.com/nix-community/nix-direnv&#34;&#62;direnv&#60;/a&#62;. It&#39;s a piece of software that let you create a environment for a directory,
and automatically switch to it when you enter said directory. The &#38;quot;environment&#38;quot; could contain envvars, and,
you guessed it: a Nix developer shell. If you have a flake.nix, add &#60;code&#62;use flake&#60;/code&#62; in your project directory&#39;s
&#60;code&#62;.envrc&#60;/code&#62; file, direnv will automatically call &#60;code&#62;nix develop&#60;/code&#62; the next time you &#60;code&#62;cd&#60;/code&#62; in. Neat!&#60;/p&#62;
&#60;p&#62;To make this work in practice, you&#39;ll want to add &#60;code&#62;.envrc&#60;/code&#62; and &#60;code&#62;.direnv/&#60;/code&#62; to your global git ignore list, as
they are personal preferences that probably shouldn&#39;t end up in git history.&#60;/p&#62;
&#60;p&#62;Ok, we are so close to solve problem &#60;code&#62;2&#60;/code&#62;, and &#60;code&#62;3&#60;/code&#62; now. In short, &#60;code&#62;nix develop&#60;/code&#62; may set up &#60;strong&#62;a&#60;/strong&#62; environment,
but it may not be &#60;strong&#62;the&#60;/strong&#62; environment that suits you the best. &#60;a href=&#34;https://github.com/nix-community/nix-direnv&#34;&#62;nix-direnv&#60;/a&#62; extends direnv to save us:&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;use flake path/to/flake#target
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;... with this in &#60;code&#62;.envrc&#60;/code&#62;, direnv will set up the Nix environment according to &#60;code&#62;path/to/flake#target&#60;/code&#62;. That
could point to any location on your hard drive! You can have a flake.nix whose &#60;code&#62;devShell&#60;/code&#62; has &#60;code&#62;cargo&#60;/code&#62;, and
&#60;code&#62;rust-analyzer&#60;/code&#62;. You can have another with &#60;code&#62;ipython&#60;/code&#62;, and &#60;code&#62;python-lsp-server&#60;/code&#62;. Mix and match to your liking to
the infinite degree...&#60;/p&#62;
&#60;p&#62;For now, I&#39;ve decided to give nix-direnv a try. Alongside my home-manager configuration, I&#39;ve also included
extra flakes for generic Python/Rust projects, and specific projects that may require a mix of tools. A lot of
the project I work on don&#39;t use flake as their package manager. With this approach, I get to customize my
setup for them each, and stay in the comfort of Nix and home-manager.&#60;/p&#62;
&#60;p&#62;direnv and nix-direnv can be configured together with home-manager. To achieve everything mentioned in this
article, including direnv&#39;s shell integration (Fish, for me), it&#39;s as simple as&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-Nix&#34;&#62;# In home manager config...
programs.direnv = {
  enable = true;
  nix-direnv = {
    enable = true;
    enableFlakes = true;
  };
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;To recap, having the snippet above in my home-manager setup, I now can enter any project&#39;s root directory and
add a &#60;code&#62;.envrc&#60;/code&#62; file with the content &#60;code&#62;use flake ~/src/dotfiles/direnvs/python&#60;/code&#62;.
&#60;code&#62;~/src/dotfiles/direnvs/python&#60;/code&#62; contains a &#60;code&#62;flake.nix&#60;/code&#62; (and a &#60;code&#62;flake.lock&#60;/code&#62;) that has the &#60;code&#62;devShell&#60;/code&#62; value
I like for all Python projects. When I &#60;code&#62;cd&#60;/code&#62; into this project, &#60;code&#62;(nix-)direnv&#60;/code&#62; will read from that &#60;code&#62;devShell&#60;/code&#62;
and set every tool listed under there. The tools are cached in a &#60;code&#62;.direnv&#60;/code&#62; directory so when I return here,
the setup is basically instantaneous. Since I make &#60;code&#62;git&#60;/code&#62; to ignore &#60;code&#62;.envrc&#60;/code&#62;, and &#60;code&#62;.direnv&#60;/code&#62; no matter where
they are, this project I&#39;m working on is unaffected by all this.&#60;/p&#62;
</description>
                <pubDate>Sat, 19 Mar 2022 00:37:01 -0700</pubDate>
                <link>https://duan.ca/2022/03/19/nix-dirnev/</link>
                <guid isPermaLink="true">https://duan.ca/2022/03/19/nix-dirnev/</guid>
            </item>
            <item>
                <title>Flake, Home Manager, and Extra Packages</title>
                <description>&#60;p&#62;So, you use a standalone home-manager, it&#39;s set up with flake, tracking a particular nixpkgs channel. How do
you use a package from another channel? This seemingly simple task took me, a Nix noob, quite a bit of
research to solve. Here&#39;s how I did it.&#60;/p&#62;
&#60;p&#62;A simple flake.nix for home-manager might look like this:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-nix&#34;&#62;{
  inputs = {
    nixpkgs.url = &#38;quot;github:nixos/nixpkgs/nixos-21.11&#38;quot;;
    home-manager.url = &#38;quot;github:nix-community/home-manager/release-21.11&#38;quot;;
    home-manager.inputs.nixpkgs.follows = &#38;quot;nixpkgs&#38;quot;;
  };
  outputs = { self, nixpkgs, home-manager }: {
    &#38;quot;dan@some-mac&#38;quot; = home-manager.lib.homeManagerConfiguration {
      username = &#38;quot;dan&#38;quot;;
      system = &#38;quot;x86_64-darwin&#38;quot;;
      homeDirectory = &#38;quot;/home/dan&#38;quot;;
      configuration = { config, pkgs ... }: {
          home.packages = [
            pkgs.hello
          ];
      };
    };
  };
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;A few things of note:&#60;/p&#62;
&#60;ol&#62;
&#60;li&#62;home manager is set to follow &#60;code&#62;nixpkgs&#60;/code&#62;, which tracks &#60;code&#62;nixos-21.11&#60;/code&#62;.&#60;/li&#62;
&#60;li&#62;&#60;code&#62;pkgs.hello&#60;/code&#62; refers to the package in &#60;code&#62;nixos-21.11&#60;/code&#62; as well.&#60;/li&#62;
&#60;/ol&#62;
&#60;p&#62;To put things in concrete terms, our goal is to put a package from a channel other than &#60;code&#62;nixos-21.11&#60;/code&#62;
alongside &#60;code&#62;pkgs.hello&#60;/code&#62;.&#60;/p&#62;
&#60;p&#62;The key to my solution is the &#60;code&#62;extraModules&#60;/code&#62; in &#60;code&#62;home-manager.lib.homeManagerConfiguration&#60;/code&#62;&#39;s argument set.
We&#39;ll leverage it to modify the environment made available to its sibling, &#60;code&#62;configuration&#60;/code&#62;.&#60;/p&#62;
&#60;p&#62;First, add the new channel as input &#60;code&#62;nixpkgs-unstable&#60;/code&#62;:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-nix&#34;&#62;{
  inputs = {
    # ...
    nixpkgs-unstable.url = &#38;quot;github:nixos/nixpkgs&#38;quot;;
  };
  ...
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Then, add a small module to &#60;code&#62;extraModules&#60;/code&#62;. In it we make &#60;code&#62;nixpkgs-unstable&#60;/code&#62; an argument to &#60;code&#62;_module&#60;/code&#62;.&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-nix&#34;&#62;{
  input = { ... };
  outputs = { self, nixpkgs, nixpkgs-unstable, home-manager }: { # Note we also pass in nixpkgs-unstable here
    &#38;quot;dan@some-mac&#38;quot; = home-manager.lib.homeManagerConfiguration {
      extraModules = [
        ({ pkgs, ... }: rec {
          _module.args.nixpkgs-unstable = import nixpkgs-unstable { inherit system; };
        })
      ];
      # ...
    };
  };
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;... now that we added &#60;code&#62;args.nixpkgs-unstable&#60;/code&#62;, it becomes available in the configuration:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-nix&#34;&#62;{
  input = { ... };
  outputs = { self, nixpkgs, nixpkgs-unstable, home-manager }: { # Note we also pass in nixpkgs-unstable here
    &#38;quot;dan@some-mac&#38;quot; = home-manager.lib.homeManagerConfiguration {
      # ...
      configuration = { config, pkgs, nixpkgs-unstable, ... }:
          home.packages = [
            pkgs.hello
            nixpkgs-unstable.python39Packages.python-lsp-server
          ];
      };
    };
  };
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;There, we made &#60;code&#62;python39Packages.python-lsp-server&#60;/code&#62; from nixpkgs&#39;s master branch appear alongside our
standard, default channel.&#60;/p&#62;
&#60;p&#62;And that&#39;s how you add packages from a different channel in a flake setup for standalone home-manager.&#60;/p&#62;
</description>
                <pubDate>Tue, 15 Mar 2022 18:53:59 -0700</pubDate>
                <link>https://duan.ca/2022/03/15/standalone-home-manager-flake-channels/</link>
                <guid isPermaLink="true">https://duan.ca/2022/03/15/standalone-home-manager-flake-channels/</guid>
            </item>
            <item>
                <title>Installing Nix on macOS 11 Big Sur</title>
                <description>&#60;p&#62;&#60;em&#62;Note: as of Feburary, 2022, the steps written below has been incorporated by the official Nix install script for macOS. This article is, therefore, obsolete.&#60;/em&#62;&#60;/p&#62;
&#60;p&#62;Here are the steps for installing nix on macOS 11 Big Sur.&#60;/p&#62;
&#60;h3&#62;Preparation&#60;/h3&#62;
&#60;p&#62;Decide on which disk the nix store is to be installed. By end of this process, you&#39;ll have a disk
name like &#60;code&#62;disk4&#60;/code&#62;.&#60;/p&#62;
&#60;p&#62;Personally, I like looking it up in the Disk Utility app:&#60;/p&#62;
&#60;p&#62;&#60;img src=&#34;/assets/2020/12/disk-utility.png&#34; alt=&#34;Disk Utility&#34; /&#62;&#60;/p&#62;
&#60;p&#62;You can also use other methods, such us the &#60;code&#62;diskutil list&#60;/code&#62; command.&#60;/p&#62;
&#60;p&#62;Have this disk name ready.&#60;/p&#62;
&#60;h3&#62;Installation&#60;/h3&#62;
&#60;h4&#62;1. Create the path &#60;code&#62;/nix&#60;/code&#62; the macOS way.&#60;/h4&#62;
&#60;p&#62;Edit or create the file &#60;code&#62;/etc/synthetic.conf&#60;/code&#62;, adding this line:&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;nix
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Reboot the Mac.&#60;/p&#62;
&#60;h4&#62;2. Create a APFS volume for the nix store.&#60;/h4&#62;
&#60;pre&#62;&#60;code&#62;sudo diskutil apfs addVolume diskX APFS &#39;Nix Store&#39; -mountpoint /nix
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Make sure to replace &#60;code&#62;diskX&#60;/code&#62; with the disk you identified in the preparation step.&#60;/p&#62;
&#60;h4&#62;3. Mount the volume.&#60;/h4&#62;
&#60;p&#62;Edit or create the file &#60;code&#62;/etc/fstab&#60;/code&#62;, adding this line:&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;LABEL=Nix\040Store /nix apfs rw,nobrowse
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Reboot the Mac.&#60;/p&#62;
&#60;h4&#62;4. Install Nix the &#38;quot;normal&#38;quot; way&#60;/h4&#62;
&#60;pre&#62;&#60;code&#62;sh &#38;lt;(curl -L https://nixos.org/nix/install)
&#60;/code&#62;&#60;/pre&#62;
&#60;h4&#62;5. You are done! Try it out. I ran this little &#60;a href=&#34;https://nix.dev/tutorials/dev-environment.html&#34;&#62;example&#60;/a&#62; as a test and things appears to work as expected.&#60;/h4&#62;
&#60;h3&#62;Bonus: using Nix in Fish shell&#60;/h3&#62;
&#60;p&#62;As a fish user, I&#39;m used to fixing things up myself since software from non-fish users usually
pretends fish doesn&#39;t exist. Anyways, in the final steps of its installation, Nix sets up a few
environment variables in a bash script. I&#39;ve adapted these specifically for fish on macOS. Add these
to your config.fish:&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;set -x NIX_PROFILES &#38;quot;/nix/var/nix/profiles/default $HOME/.nix-profile&#38;quot;
set -x NIX_SSL_CERT_FILE &#38;quot;$HOME/.nix-profile/etc/ssl/certs/ca-bundle.crt&#38;quot;
set -x NIX_PATH /nix $HOME/.nix-defexpr/channels
set -x PATH $HOME/.nix-profile/bin $PATH
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;It shouldn&#39;t be to hard to do this on other OSes. The relevant information is in
&#60;code&#62;~/.nix-profile/etc/profile.d/nix.sh&#60;/code&#62;.&#60;/p&#62;
</description>
                <pubDate>Sun, 13 Dec 2020 12:00:52 -0800</pubDate>
                <link>https://duan.ca/2020/12/13/nix-on-macos-11-big-sur/</link>
                <guid isPermaLink="true">https://duan.ca/2020/12/13/nix-on-macos-11-big-sur/</guid>
            </item>
            <item>
                <title>Naive NixOS Rust Development</title>
                <description>&#60;p&#62;tl;dr: To work on Rust project with nix-shell, rls and extensions such as
&#60;code&#62;rust-analysis&#60;/code&#62;, &#60;code&#62;rust-src&#60;/code&#62;, without caring too much about specific Rust
toolchain version (except for it being &#60;code&#62;stable&#60;/code&#62;), use the following &#60;code&#62;shell.nix&#60;/code&#62;:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-nix&#34;&#62;let
  moz_overlay = import (builtins.fetchTarball https://github.com/mozilla/nixpkgs-mozilla/archive/master.tar.gz);
  nixpkgs = import &#38;lt;nixpkgs&#38;gt; {
    overlays = [ moz_overlay ];
  };
  ruststable = (nixpkgs.latest.rustChannels.stable.rust.override {
    extensions = [ &#38;quot;rust-src&#38;quot; &#38;quot;rust-analysis&#38;quot; ];}
  );
in
  with nixpkgs;
  stdenv.mkDerivation {
    name = &#38;quot;rust&#38;quot;;
    buildInputs = [ rustup ruststable ];
  }
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;When you have a Nix hammer, everything looks like a Nix expression.&#60;/p&#62;
&#60;p&#62;Having used NixOS on a real PC for a number of days, this is the impression
I get from the world of Nix. Unfortunately, so far, it&#39;s been a negative for me.&#60;/p&#62;
&#60;p&#62;One of the most exciting thing I want to use Nix for is to bootstrap development
environment with &#60;code&#62;nix-shell&#60;/code&#62;. I imagined it to be similar to using &#60;a href=&#34;https://pipenv-fork.readthedocs.io/en/latest/&#34;&#62;pipenv&#60;/a&#62;
with Python, except for everything. Well, I&#39;ve since learned that it&#39;s not true
(yet?) for many reasons.&#60;/p&#62;
&#60;p&#62;Modern programming languages come with their own attempt at &#60;em&#62;reproducibility&#60;/em&#62;.
Some does it better than others. To make it concrete, I&#39;m talking about things
like &#60;a href=&#34;https://haskellstack.org&#34;&#62;Stack&#60;/a&#62; for Haskell or &#60;a href=&#34;https://rustup.rs/&#34;&#62;rustup&#60;/a&#62; for Rust: given the source code, how do
I make it build in the way the project intended? What&#39;s the correct version of
the compiler, runtime, and tools that works best with this revision of the
source code? The common solution usually follows this pattern: as author of
a project, specify as much as you can, the environment best suited for the
current state of the project. As a &#38;quot;builder&#38;quot;, use a &#60;em&#62;single program&#60;/em&#62; that&#39;s
capable of updating itself, as well as ensuring that the project builds exactly
as specified, including managing the compiler/runtime/tooling versions, etc.&#60;/p&#62;
&#60;p&#62;This &#60;em&#62;single program&#60;/em&#62;&#39;s role is very much the same as the Nix system, except the
latter is independent of programming languages: &#60;code&#62;rustup&#60;/code&#62; installs Rust, so does
Nix. That&#39;s a bad thing. As a package manager, Nix either have to tightly
integrate with each of these other package managers, leveraging their evolving
behaviors to give its user the build environment; or, it must replace them.
The former is impractical; the latter, well, sucks.&#60;/p&#62;
&#60;p&#62;Back to reality. This is the experience I want to have with NixOS: Some programs
I use daily such as Alacritty, NeoVim, Firfox, etc, are installed globally and
readily available. They are part of my &#60;code&#62;/etc/nixos/configuration.nix&#60;/code&#62;. So far so
good. Now, I regularly program in a few languages. For each of the project, I&#39;d
like to have a &#60;code&#62;shell.nix&#60;/code&#62; that brings in its compilers, libraries, LSP servers,
etc. This is what &#60;code&#62;nix-shell&#60;/code&#62; is supposed to give me! This is known as the &#38;quot;per
project&#38;quot; setup.&#60;/p&#62;
&#60;p&#62;Let&#39;s see: with Rust, that means &#60;code&#62;rustc&#60;/code&#62; (compiler), &#60;code&#62;cargo&#60;/code&#62; (package manager),
&#60;code&#62;rls&#60;/code&#62;, &#60;code&#62;rust-src&#60;/code&#62; and &#60;code&#62;rust-analysis&#60;/code&#62; (LSP). In macOS, I&#39;d install all of these
globally with &#60;code&#62;rustup&#60;/code&#62;. In NixOS...well, I can ask for &#60;code&#62;rustup&#60;/code&#62; for my project:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-nix&#34;&#62;with import &#38;lt;nixpkgs&#38;gt; {};

stdenv.mkDerivation {
  name = &#38;quot;rust&#38;quot;;
  nativeBuildInputs = [ rustup ];
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;...which gives me &#60;code&#62;rustup&#60;/code&#62; and nothing else. That&#39;s right, you don&#39;t even get
a &#60;code&#62;rustc&#60;/code&#62; after running &#60;code&#62;nix-shell&#60;/code&#62;. But &#60;code&#62;rustup&#60;/code&#62; can get you everything else,
all I need to do is ask. Hmm, do I need to run a series of set-up commands with
&#60;code&#62;rustup&#60;/code&#62; every time I enter the environment? No? I just need to run it the first
time? Until the cached tools get deleted by some garbage collection mechanism?
That seems unsatisfying, doesn&#39;t it?&#60;/p&#62;
&#60;p&#62;Instead of &#60;code&#62;rustup&#60;/code&#62;, I could also ask Nix to use the &#60;code&#62;rustc&#60;/code&#62;/&#60;code&#62;cargo&#60;/code&#62;/&#60;code&#62;rls&#60;/code&#62; it
knows about directly. This is marginally better. Except I still need &#60;code&#62;rust-src&#60;/code&#62;
and &#60;code&#62;rust-analysis&#60;/code&#62; for my needs. As far as I can tell, these &#60;a href=&#34;https://github.com/rust-lang/rls&#34;&#62;RLS&#60;/a&#62; components
are out of Nix&#39;s control (as of today).&#60;/p&#62;
&#60;p&#62;Everywhere on the internet I looked, for every problem that
Nix-the-package-manager doesn&#39;t work out-of-the-box, there&#39;s someone responding
along the line of &#38;quot;you can write some Nix expression yourself&#38;quot;. In other words,
Nix-the-language is powerful enough to solve it, probably. In the case of Rust,
luckily, Mozilla wrote enough Nix expressions for us and provides them via an
&#60;a href=&#34;https://github.com/mozilla/nixpkgs-mozilla&#34;&#62;overlay&#60;/a&#62;. These expressions are rich enough to meet my needs.
As you can see in the tl;dr at the top, when entering the development
environment, nix-shell would: download the overlay&#39;s source code (from the
internet, or local cache), load the expression it includes, mix in my
customization, and execute it.&#60;/p&#62;
&#60;p&#62;That marks the end of my search. I like the final solution because it&#39;s mostly
&#38;quot;vanilla&#38;quot; Nix and doesn&#39;t require me to mess with a bunch of other tools. For
solutions that do, read &#60;a href=&#34;https://christine.website/blog/how-i-start-nix-2020-03-08&#34;&#62;this&#60;/a&#62;.&#60;/p&#62;
&#60;hr /&#62;
&#60;p&#62;At end of the day, my needs are pretty basic: consistency from rustup and
convenience from nix-shell. I didn&#39;t need to pin the compiler to a specific Rust
release, or checksum the final build output.&#60;/p&#62;
&#60;p&#62;I&#39;m very new to both technologies so there may be a follow-up post sometime in
the future.&#60;/p&#62;
</description>
                <pubDate>Thu, 07 May 2020 11:04:58 -0700</pubDate>
                <link>https://duan.ca/2020/05/07/nix-rust-development/</link>
                <guid isPermaLink="true">https://duan.ca/2020/05/07/nix-rust-development/</guid>
            </item>
    </channel>
</rss>