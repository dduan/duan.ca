<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About Pathos</title>
        <link>https://duan.ca/tag/pathos/</link>
        <atom:link href="https://duan.ca/tag/pathos/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>Fantastic Beasts in C and Where To Find Them in Swift</title>
                <description>&lt;p&gt;Swift has a pretty decent C-interoperability story. But C has many features! Today, I&#x27;ll tell you
a story involving a few not-so-well supported C features and Swift.&lt;&#x2f;p&gt;
&lt;p&gt;It all started when I decided to re-write &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;dduan&#x2f;Pathos&quot;&gt;Pathos&lt;&#x2f;a&gt; with Windows support. One of the library&#x27;s
offering is reading the literal target of a symbolic link: if &lt;code&gt;b&lt;&#x2f;code&gt; is a link to &lt;code&gt;a&lt;&#x2f;code&gt;, then
&lt;code&gt;Path(&amp;quot;b&amp;quot;).readSymlink()&lt;&#x2f;code&gt; should return a another path that&#x27;s equivalent to &lt;code&gt;Path(&amp;quot;a&amp;quot;)&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The Windows API that returns this information is &lt;a href=&quot;https:&#x2f;&#x2f;docs.microsoft.com&#x2f;en-us&#x2f;windows&#x2f;win32&#x2f;api&#x2f;ioapiset&#x2f;nf-ioapiset-deviceiocontrol&quot;&gt;DeviceIoControl&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source c&quot;&gt;&lt;span class=&quot;support type windows c&quot;&gt;BOOL&lt;&#x2f;span&gt; &lt;span class=&quot;meta function c&quot;&gt;&lt;span class=&quot;entity name function c&quot;&gt;DeviceIoControl&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;meta function parameters c&quot;&gt;&lt;span class=&quot;meta group c&quot;&gt;&lt;span class=&quot;punctuation section group begin c&quot;&gt;(&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;meta function parameters c&quot;&gt;&lt;span class=&quot;meta group c&quot;&gt;
  &lt;span class=&quot;support type windows c&quot;&gt;HANDLE&lt;&#x2f;span&gt;       &lt;span class=&quot;variable parameter c&quot;&gt;hDevice&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation separator c&quot;&gt;,&lt;&#x2f;span&gt;
  &lt;span class=&quot;support type windows c&quot;&gt;DWORD&lt;&#x2f;span&gt;        &lt;span class=&quot;variable parameter c&quot;&gt;dwIoControlCode&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation separator c&quot;&gt;,&lt;&#x2f;span&gt;
  &lt;span class=&quot;support type windows c&quot;&gt;LPVOID&lt;&#x2f;span&gt;       &lt;span class=&quot;variable parameter c&quot;&gt;lpInBuffer&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation separator c&quot;&gt;,&lt;&#x2f;span&gt;
  &lt;span class=&quot;support type windows c&quot;&gt;DWORD&lt;&#x2f;span&gt;        &lt;span class=&quot;variable parameter c&quot;&gt;nInBufferSize&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation separator c&quot;&gt;,&lt;&#x2f;span&gt;
  &lt;span class=&quot;support type windows c&quot;&gt;LPVOID&lt;&#x2f;span&gt;       &lt;span class=&quot;variable parameter c&quot;&gt;lpOutBuffer&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation separator c&quot;&gt;,&lt;&#x2f;span&gt;
  &lt;span class=&quot;support type windows c&quot;&gt;DWORD&lt;&#x2f;span&gt;        &lt;span class=&quot;variable parameter c&quot;&gt;nOutBufferSize&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation separator c&quot;&gt;,&lt;&#x2f;span&gt;
  &lt;span class=&quot;support type windows c&quot;&gt;LPDWORD&lt;&#x2f;span&gt;      &lt;span class=&quot;variable parameter c&quot;&gt;lpBytesReturned&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation separator c&quot;&gt;,&lt;&#x2f;span&gt;
  LPOVERLAPPED lpOverlapped
&lt;span class=&quot;punctuation section group end c&quot;&gt;)&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Notice anything weird? Hint: &lt;code&gt;LPVOID&lt;&#x2f;code&gt; is &lt;code&gt;void *&lt;&#x2f;code&gt; in standard C.&lt;&#x2f;p&gt;
&lt;p&gt;This function is, for the lack of better words, polymorphic: depending on your input, it can intake
and output different types. As a caller, it is your responsibility to look up what type is needed
and cast them to and from those &lt;code&gt;void *&lt;&#x2f;code&gt;s. The size of the data structure is returned as well. We&#x27;ll
have a lot to talk about that later.&lt;&#x2f;p&gt;
&lt;p&gt;Perhaps, surprisingly, this is not too hard to deal with in Swift. In my &lt;a href=&quot;&#x2f;2020&#x2f;09&#x2f;09&#x2f;free-c-strings&quot;&gt;last article&lt;&#x2f;a&gt;,
I detailed how we can use an Swift API to work with C buffers:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&#x2f;&lt;&#x2f;span&gt; get the file `handle`...&lt;&#x2f;span&gt;
&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&#x2f;&lt;&#x2f;span&gt; now call `DeviceIoControl`&lt;&#x2f;span&gt;
&lt;span class=&quot;keyword variable&quot;&gt;var&lt;&#x2f;span&gt; data = &lt;span class=&quot;support class&quot;&gt;ContiguousArray&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span class=&quot;support class&quot;&gt;CChar&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;(
    &lt;span class=&quot;variable parameter&quot;&gt;unsafeUninitializedCapacity&lt;&#x2f;span&gt;: kMax
) { buffer, count &lt;span class=&quot;keyword control&quot;&gt;in&lt;&#x2f;span&gt;
    &lt;span class=&quot;keyword variable&quot;&gt;var&lt;&#x2f;span&gt; &lt;span class=&quot;variable parameter&quot;&gt;size&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;DWORD&lt;&#x2f;span&gt; = &lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;
    &lt;span class=&quot;support class&quot;&gt;DeviceIoControl&lt;&#x2f;span&gt;(
        handle,
        &lt;span class=&quot;support class&quot;&gt;FSCTL_GET_REPARSE_POINT&lt;&#x2f;span&gt;,
        &lt;span class=&quot;constant language nil&quot;&gt;nil&lt;&#x2f;span&gt;,
        &lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;,
        buffer&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;baseAddress,
        &lt;span class=&quot;support class&quot;&gt;DWORD&lt;&#x2f;span&gt;(buffer&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;count),
        &amp;amp;size,
        &lt;span class=&quot;constant language nil&quot;&gt;nil&lt;&#x2f;span&gt;
    )
    count = &lt;span class=&quot;support class&quot;&gt;Int&lt;&#x2f;span&gt;(size)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So this fills the array of &lt;code&gt;CChar&lt;&#x2f;code&gt;s with the necessary bytes for out result. I named the variable
&lt;code&gt;data&lt;&#x2f;code&gt; because it is exactly the same concept as &lt;code&gt;Foundation&lt;&#x2f;code&gt;&#x27;s Data, as most Swift programmers
know.&lt;&#x2f;p&gt;
&lt;p&gt;As promised, we&#x27;ll cast this data to the actual type so that we can retrieve information from its
bytes. Side note: casting in this context is a documented usage, So it really is more awkward rather
than bad. And there&#x27;s a safe way to do it:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;withUnsafePointer(&lt;span class=&quot;variable parameter&quot;&gt;to&lt;&#x2f;span&gt;: data) {
    $&lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;withMemoryRebound(
        &lt;span class=&quot;variable parameter&quot;&gt;to&lt;&#x2f;span&gt;: [&lt;span class=&quot;support class&quot;&gt;ReparseDataBuffer&lt;&#x2f;span&gt;].&lt;span class=&quot;constant language enum&quot;&gt;self&lt;&#x2f;span&gt;,
        &lt;span class=&quot;variable parameter&quot;&gt;capacity&lt;&#x2f;span&gt;: &lt;span class=&quot;constant numeric decimal&quot;&gt;1&lt;&#x2f;span&gt;
    ) { buffer &lt;span class=&quot;keyword control&quot;&gt;in&lt;&#x2f;span&gt;
        &lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; first element in `buffer` is &lt;&#x2f;span&gt;
        &lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&#x2f;&lt;&#x2f;span&gt; a `ReparseDataBuffer`! Yay&lt;&#x2f;span&gt;
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;em&gt;It&#x27;s very important to note that &lt;code&gt;ReparseDataBuffer&lt;&#x2f;code&gt; is a struct with fixed, predictable layout,
that the API &lt;code&gt;DeviceIoControl&lt;&#x2f;code&gt; promises to return. In practice, this means it is defined in C. Swift
does not currently guarantee struct layout. So unless you really know what you are doing and don&#x27;t
care about forward compatibility, you should not do this with Swift structs.&lt;&#x2f;em&gt;&lt;&#x2f;p&gt;
&lt;p&gt;So far this story has been boring for avid Swift programmers. Fear not, things will get spicy now.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s talk about this &lt;code&gt;ReparseDataBuffer&lt;&#x2f;code&gt;. It&#x27;s an imported C type with a few notable features.&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source c&quot;&gt;&lt;span class=&quot;storage type c&quot;&gt;typedef&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;struct&lt;&#x2f;span&gt; &lt;span class=&quot;meta block c&quot;&gt;&lt;span class=&quot;punctuation section block begin c&quot;&gt;{&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;long&lt;&#x2f;span&gt;  ReparseTag&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; ReparseDataLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; Reserved&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;union&lt;&#x2f;span&gt; &lt;span class=&quot;meta block c&quot;&gt;&lt;span class=&quot;punctuation section block begin c&quot;&gt;{&lt;&#x2f;span&gt;
    &lt;span class=&quot;storage type c&quot;&gt;struct&lt;&#x2f;span&gt; &lt;span class=&quot;meta block c&quot;&gt;&lt;span class=&quot;punctuation section block begin c&quot;&gt;{&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; SubstituteNameOffset&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; SubstituteNameLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; PrintNameOffset&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; PrintNameLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;long&lt;&#x2f;span&gt;  Flags&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
      wchar_t  PathBuffer&lt;span class=&quot;meta brackets c&quot;&gt;&lt;span class=&quot;punctuation section brackets begin c&quot;&gt;[&lt;&#x2f;span&gt;&lt;span class=&quot;constant numeric c&quot;&gt;1&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation section brackets end c&quot;&gt;]&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
    &lt;span class=&quot;punctuation section block end c&quot;&gt;}&lt;&#x2f;span&gt;&lt;&#x2f;span&gt; SymbolicLinkReparseBuffer&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
    &lt;span class=&quot;storage type c&quot;&gt;struct&lt;&#x2f;span&gt; &lt;span class=&quot;meta block c&quot;&gt;&lt;span class=&quot;punctuation section block begin c&quot;&gt;{&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; SubstituteNameOffset&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; SubstituteNameLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; PrintNameOffset&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; PrintNameLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
      wchar_t  PathBuffer&lt;span class=&quot;meta brackets c&quot;&gt;&lt;span class=&quot;punctuation section brackets begin c&quot;&gt;[&lt;&#x2f;span&gt;&lt;span class=&quot;constant numeric c&quot;&gt;1&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation section brackets end c&quot;&gt;]&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
    &lt;span class=&quot;punctuation section block end c&quot;&gt;}&lt;&#x2f;span&gt;&lt;&#x2f;span&gt; MountPointReparseBuffer&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
    &lt;span class=&quot;storage type c&quot;&gt;struct&lt;&#x2f;span&gt; &lt;span class=&quot;meta block c&quot;&gt;&lt;span class=&quot;punctuation section block begin c&quot;&gt;{&lt;&#x2f;span&gt;
      &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;char&lt;&#x2f;span&gt; DataBuffer&lt;span class=&quot;meta brackets c&quot;&gt;&lt;span class=&quot;punctuation section brackets begin c&quot;&gt;[&lt;&#x2f;span&gt;&lt;span class=&quot;constant numeric c&quot;&gt;1&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation section brackets end c&quot;&gt;]&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
    &lt;span class=&quot;punctuation section block end c&quot;&gt;}&lt;&#x2f;span&gt;&lt;&#x2f;span&gt; GenericReparseBuffer&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;punctuation section block end c&quot;&gt;}&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
&lt;span class=&quot;punctuation section block end c&quot;&gt;}&lt;&#x2f;span&gt;&lt;&#x2f;span&gt; &lt;span class=&quot;entity name type typedef c&quot;&gt;ReparseDataBuffer&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Feature #1: it has a &lt;em&gt;union member&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;A &lt;code&gt;union&lt;&#x2f;code&gt; in C is an area in memory that could be any of the types specified in the union:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source c&quot;&gt;&lt;span class=&quot;comment line double-slash c&quot;&gt;&lt;span class=&quot;punctuation definition comment c&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; X.a is a `char` and X.b is a `uint64_t`. 
&#x2f;&#x2f; And they occupy the same memory because
&#x2f;&#x2f; only 1 of them exists at a time.
typedef union {
    char a;
    uint64_t b;
} X;
&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Swift does not own a direct analog for this. So if we import this &lt;code&gt;ReparseDataBuffer&lt;&#x2f;code&gt; definition,
there wouldn&#x27;t be a good way to access the data inside the union.&lt;&#x2f;p&gt;
&lt;p&gt;As I pointed out in the comment, members of a union occupy the same space in memory. The largest
member defines the size of that space, so everyone can fit inside of it. Each union member
interprets the same bytes according to their own definition. Given this knowledge, we can derive
a solution that works around Swift&#x27;s limitations: break up the union (sorry, this whole paragraph
reads super suggestive of the real world union. It&#x27;s probably why this word is picked for this data
structure in the first place. But I do not intend to say anything about the real world here)!&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source c&quot;&gt;&lt;span class=&quot;storage type c&quot;&gt;typedef&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;struct&lt;&#x2f;span&gt; &lt;span class=&quot;meta block c&quot;&gt;&lt;span class=&quot;punctuation section block begin c&quot;&gt;{&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;long&lt;&#x2f;span&gt; reparseTag&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; reparseDataLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; reserved&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; substituteNameOffset&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; substituteNameLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; printNameOffset&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; printNameLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;long&lt;&#x2f;span&gt; flags&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  wchar_t pathBuffer&lt;span class=&quot;meta brackets c&quot;&gt;&lt;span class=&quot;punctuation section brackets begin c&quot;&gt;[&lt;&#x2f;span&gt;&lt;span class=&quot;constant numeric c&quot;&gt;1&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation section brackets end c&quot;&gt;]&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
&lt;span class=&quot;punctuation section block end c&quot;&gt;}&lt;&#x2f;span&gt;&lt;&#x2f;span&gt; &lt;span class=&quot;entity name type typedef c&quot;&gt;SymbolicLinkReparseBuffer&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;

&lt;span class=&quot;storage type c&quot;&gt;typedef&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;struct&lt;&#x2f;span&gt; &lt;span class=&quot;meta block c&quot;&gt;&lt;span class=&quot;punctuation section block begin c&quot;&gt;{&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;long&lt;&#x2f;span&gt; reparseTag&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; reparseDataLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; reserved&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; substituteNameOffset&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; substituteNameLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; printNameOffset&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  &lt;span class=&quot;storage type c&quot;&gt;unsigned&lt;&#x2f;span&gt; &lt;span class=&quot;storage type c&quot;&gt;short&lt;&#x2f;span&gt; printNameLength&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
  wchar_t pathBuffer&lt;span class=&quot;meta brackets c&quot;&gt;&lt;span class=&quot;punctuation section brackets begin c&quot;&gt;[&lt;&#x2f;span&gt;&lt;span class=&quot;constant numeric c&quot;&gt;1&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation section brackets end c&quot;&gt;]&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;
&lt;span class=&quot;punctuation section block end c&quot;&gt;}&lt;&#x2f;span&gt;&lt;&#x2f;span&gt; &lt;span class=&quot;entity name type typedef c&quot;&gt;MountPointReparseBuffer&lt;&#x2f;span&gt;&lt;span class=&quot;punctuation terminator c&quot;&gt;;&lt;&#x2f;span&gt;

&lt;span class=&quot;comment line double-slash c&quot;&gt;&lt;span class=&quot;punctuation definition comment c&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; we don&amp;#39;t care about the 3rd union
&#x2f;&#x2f; member in this use case
&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Conveniently for us, the union member in &lt;code&gt;ReparseDataBuffer&lt;&#x2f;code&gt; is at the end. So we don&#x27;t need to
worry about padding the unused space for smaller alternatives. Back in Swift, instead of dealing
with &lt;code&gt;ReparseDataBuffer&lt;&#x2f;code&gt; directly, we can work with &lt;code&gt;SymbolicLinkReparseBuffer&lt;&#x2f;code&gt; or
&lt;code&gt;MountPointReparseBuffer&lt;&#x2f;code&gt;, depending on our expectation of which union member to read.&lt;&#x2f;p&gt;
&lt;p&gt;Yeah, this is a good time to mention that, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;dduan&#x2f;Pathos&quot;&gt;Pathos&lt;&#x2f;a&gt; has to include copies of these definition in a
separate C module. Not only because we need to &amp;quot;break up the union&amp;quot;, the original definition is also
only accessible after importing some headers in the NT kernel. So the standard &lt;code&gt;import WinSDK&lt;&#x2f;code&gt; won&#x27;t
suffice.&lt;&#x2f;p&gt;
&lt;p&gt;Moving on to notable feature #2. The last member of both &lt;code&gt;SymbolicLinkReparseBuffer&lt;&#x2f;code&gt; and
&lt;code&gt;MountPointReparseBuffer&lt;&#x2f;code&gt; &lt;code&gt;pathBuffer&lt;&#x2f;code&gt; is a 1-character long array...why?&lt;&#x2f;p&gt;
&lt;p&gt;In C, this is a &lt;em&gt;flexible array member&lt;&#x2f;em&gt;. Such member must always appear at the end of a struct.
The word &amp;quot;flexible&amp;quot; in this context refers to the amount of memory allocated for this type of
structs : it can vary according to the length of the array as needed. The member such as
&lt;code&gt;pathBuffer&lt;&#x2f;code&gt; is here to provide access to the beginning of the buffer.&lt;&#x2f;p&gt;
&lt;p&gt;To Swift, &lt;code&gt;pathBuffer&lt;&#x2f;code&gt; looks like a single &lt;code&gt;UInt16&lt;&#x2f;code&gt;. The language obviously don&#x27;t have a good idea
of this C feature. So how to we get the rest of the data from this array?&lt;&#x2f;p&gt;
&lt;p&gt;Once again, we have to lean on our understanding of memory layout in C structs.&lt;&#x2f;p&gt;
&lt;p&gt;As is common in APIs for flexible array members, the length of the array trailing the struct is
provide to us. Let&#x27;s call it &lt;code&gt;flexibleLength&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2f;assets&#x2f;2020&#x2f;09&#x2f;flexible_array_member.png&quot; alt=&quot;Illustration of memory layout for a C struct with flexible array member&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We already have the memory for these structs in bytes (remember &lt;code&gt;data&lt;&#x2f;code&gt;?). And we can get the size
for the fixed potion of the structs with&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;&lt;span class=&quot;keyword variable&quot;&gt;let&lt;&#x2f;span&gt; fixedStructSize = &lt;span class=&quot;support class&quot;&gt;MemoryLayout&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;
    &lt;span class=&quot;support class&quot;&gt;SymbolicLinkReparseBuffer&lt;&#x2f;span&gt;
&amp;gt;.&lt;span class=&quot;constant language enum&quot;&gt;stride&lt;&#x2f;span&gt;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Putting it all together, we can get the full content of the array by&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;chopping off the content for struct itself,&lt;&#x2f;li&gt;
&lt;li&gt;casting the rest of the raw buffer to the expected element type, and&lt;&#x2f;li&gt;
&lt;li&gt;include the last member in this struct as the first element in the array&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; Include the first element, which is at&lt;&#x2f;span&gt;
&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; the end of the fixed struct potion.&lt;&#x2f;span&gt;
&lt;span class=&quot;keyword variable&quot;&gt;let&lt;&#x2f;span&gt; arrayStart = fixedStructSize - &lt;span class=&quot;constant numeric decimal&quot;&gt;1&lt;&#x2f;span&gt;
&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; Cast the data buffer so it&amp;#39;s composed &lt;&#x2f;span&gt;
&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; of `wchar_t` aka `UInt16`s.&lt;&#x2f;span&gt;
&lt;span class=&quot;keyword variable&quot;&gt;let&lt;&#x2f;span&gt; array = withUnsafePointer(&lt;span class=&quot;variable parameter&quot;&gt;to&lt;&#x2f;span&gt;: data) {
    $&lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;withMemoryRebound(
        &lt;span class=&quot;variable parameter&quot;&gt;to&lt;&#x2f;span&gt;: [&lt;span class=&quot;support class&quot;&gt;UInt16&lt;&#x2f;span&gt;].&lt;span class=&quot;constant language enum&quot;&gt;self&lt;&#x2f;span&gt;,
        &lt;span class=&quot;variable parameter&quot;&gt;capacity&lt;&#x2f;span&gt;: data&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;count &#x2f; &lt;span class=&quot;constant numeric decimal&quot;&gt;2&lt;&#x2f;span&gt;
    ) { sixteenBitData &lt;span class=&quot;keyword control&quot;&gt;in&lt;&#x2f;span&gt;
        &lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; chop off the non-array potion&lt;&#x2f;span&gt;
        sixteenBitData&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;pointee[
            arrayStart ..&amp;lt; (arrayStart + flexibleLength)
        ]
    }
}

&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; now, go nuts on the array! You earned it!&lt;&#x2f;span&gt;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Considerations such as error handling are intentionally left out in this article. You can checkout
the source code of &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;dduan&#x2f;Pathos&quot;&gt;Pathos&lt;&#x2f;a&gt; (on the &lt;code&gt;next&lt;&#x2f;code&gt; branch) for the full glory.&lt;&#x2f;p&gt;
&lt;p&gt;Anyways, the flexible array member turns out to be the literal target of the symbolic link. So here
is the end of our story. I&#x27;m interested to hear about alternative approaches for dealing with union
members and flexible array members in Swift. Let me know on &lt;a href=&quot;https:&#x2f;&#x2f;twitter.com&#x2f;daniel_duan&quot;&gt;Twitter&lt;&#x2f;a&gt;, or &lt;a href=&quot;&quot;&gt;Twitch&lt;&#x2f;a&gt; when I&#x27;m
streaming!&lt;&#x2f;p&gt;
</description>
                <pubDate>Sat, 12 Sep 2020 23:11:48 -0700</pubDate>
                <link>https://duan.ca/2020/09/12/fantastic-c-beasts-and-where-to-find-them-in-swift/</link>
                <guid isPermaLink="true">https://duan.ca/2020/09/12/fantastic-c-beasts-and-where-to-find-them-in-swift/</guid>
            </item>
            <item>
                <title>Faster C Strings in Swift</title>
                <description>&lt;p&gt;One of the goals in the re-write of my VFS library &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;dduan&#x2f;Pathos&quot;&gt;Pathos&lt;&#x2f;a&gt; is to make it go
fast. What does that mean when most of the time users are hitting the hard
drive when running your code? Well, let&#x27;s not dwell on that for now.&lt;&#x2f;p&gt;
&lt;p&gt;A library like this passes &lt;em&gt;file paths&lt;&#x2f;em&gt; back and forth with C APIs from the OS
a lot. So one way to go fast is to keep the original representation of the paths
as they are provided to us. On macOS and Linux (and other OSes that Swift
doesn&#x27;t officially support yet), paths are bought and sold in the so called
&amp;quot;C strings&amp;quot;: &lt;code&gt;NUL&lt;&#x2f;code&gt;-terminated bytes (8-bit integers) with POSIX APIs and 16-bit
values on Windows with &lt;code&gt;UNICODE&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s walk over a couple of examples. Here&#x27;s how to get the current working
directory:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source c&quot;&gt;&lt;span class=&quot;comment line double-slash c&quot;&gt;&lt;span class=&quot;punctuation definition comment c&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; POSIX
char *getcwd(char *buf, size_t size);

&#x2f;&#x2f; Windows
&#x2f;&#x2f; LPTSTR (with right environment) is `wchar_t *`
DWORD GetCurrentDirectory(
    DWORD nBufferLength,
    LPTSTR lpBuffer
);
&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The expected steps for using APIs like this are the following:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;you allocate a buffer large enough to store any result you expect.&lt;&#x2f;li&gt;
&lt;li&gt;you give the buffer to the C function.&lt;&#x2f;li&gt;
&lt;li&gt;the C function fills the buffer with some characters, and a &lt;code&gt;NUL&lt;&#x2f;code&gt; (or &lt;code&gt;0&lt;&#x2f;code&gt;)
right after the last character in the result.&lt;&#x2f;li&gt;
&lt;li&gt;the function use a separate variable to tell you the size of the actual
result, not counting the &lt;code&gt;NUL&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;It&#x27;s very generous of these functions to give us the size of the result. Because
the point of using &lt;code&gt;NUL&lt;&#x2f;code&gt; to terminate &amp;quot;strings&amp;quot; is to avoid having to use
a separate size. Let&#x27;s use &lt;em&gt;setting the current working directory&lt;&#x2f;em&gt; as the next
example:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source c&quot;&gt;&lt;span class=&quot;comment line double-slash c&quot;&gt;&lt;span class=&quot;punctuation definition comment c&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; POSIX
int chdir(const char *path);

&#x2f;&#x2f; Windows
BOOL SetCurrentDirectory(LPCTSTR lpPathName);
&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Yup, these APIs don&#x27;t need you to tell them the content size of your buffer. But
if your content doesn&#x27;t end with a &lt;code&gt;NUL&lt;&#x2f;code&gt;, they&#x27;ll happily read beyond your
intended stopping point until it finds a random &lt;code&gt;0&lt;&#x2f;code&gt; in memory.&lt;&#x2f;p&gt;
&lt;p&gt;Anyways, this is pretty classic C stuff. Now let&#x27;s talk about Swift!&lt;&#x2f;p&gt;
&lt;p&gt;The default option to store a file path for most should be a &lt;code&gt;Swift.String&lt;&#x2f;code&gt;,
which is a encoding-agnostic, Unicode glyph based list of characters. But as
I mentioned earlier, I want to avoid the cost of decoding and encoding in the
case where the path is only passing through the Swift code from C to C, without
being analyzed or modified. (If you need a refresher, &lt;a href=&quot;https:&#x2f;&#x2f;youtu.be&#x2f;Vy2r21kli0Q&quot;&gt;I recently made a video
on Unicode and encoding&lt;&#x2f;a&gt;.) So I chose to use an
&lt;a href=&quot;https:&#x2f;&#x2f;developer.apple.com&#x2f;documentation&#x2f;swift&#x2f;contiguousarray&quot;&gt;ContiguousArray&lt;&#x2f;a&gt; to store these C values:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; Simplified for POSIX&lt;&#x2f;span&gt;
&lt;span class=&quot;entity name type&quot;&gt;&lt;span class=&quot;keyword entity&quot;&gt;struct&lt;&#x2f;span&gt; &lt;span class=&quot;entity name type&quot;&gt;&lt;span class=&quot;support class&quot;&gt;Path&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;&#x2f;span&gt; {
    &lt;span class=&quot;keyword variable&quot;&gt;let&lt;&#x2f;span&gt; &lt;span class=&quot;variable parameter&quot;&gt;storage&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;ContiguousArray&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span class=&quot;support class&quot;&gt;CChar&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;
    &lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; ...&lt;&#x2f;span&gt;
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;code&gt;ContiguousArray&lt;&#x2f;code&gt; (and &lt;code&gt;Array&lt;&#x2f;code&gt;) provides an excellent way to interact with C
APIs we encountered earlier:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;&lt;span class=&quot;meta function&quot;&gt;&lt;span class=&quot;meta toc-list&quot;&gt;&lt;span class=&quot;storage type function&quot;&gt;init&lt;&#x2f;span&gt;(
    &lt;span class=&quot;variable parameter&quot;&gt;unsafeUninitializedCapacity&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;Int&lt;&#x2f;span&gt;,
    initializingWith &lt;span class=&quot;variable parameter&quot;&gt;initializer&lt;&#x2f;span&gt;: (
        inout &lt;span class=&quot;support class&quot;&gt;UnsafeMutableBufferPointer&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span class=&quot;support class&quot;&gt;Element&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;,
        inout &lt;span class=&quot;support class&quot;&gt;Int&lt;&#x2f;span&gt;
    ) &lt;span class=&quot;keyword control&quot;&gt;throws&lt;&#x2f;span&gt; -&amp;gt; &lt;span class=&quot;support class&quot;&gt;Void&lt;&#x2f;span&gt;
)&lt;&#x2f;span&gt;&lt;&#x2f;span&gt; &lt;span class=&quot;keyword control&quot;&gt;rethrows&lt;&#x2f;span&gt;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Don&#x27;t let the complex-looking signature intimidate you. Essentially, it gives
you write access to the array&#x27;s memory right after its allocation, but before
Swift does standard initialization to it. It works really well with the C APIs
we looked at earlier:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; Store the current directory in a ContiguousArray&lt;&#x2f;span&gt;
&lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; Using the Windows API&lt;&#x2f;span&gt;
&lt;span class=&quot;keyword variable&quot;&gt;let&lt;&#x2f;span&gt; storage = &lt;span class=&quot;support class&quot;&gt;ContiguousArray&lt;&#x2f;span&gt;(
    &lt;span class=&quot;variable parameter&quot;&gt;unsafeUninitializedCapacity&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;Int&lt;&#x2f;span&gt;(&lt;span class=&quot;support class&quot;&gt;MAX_PATH&lt;&#x2f;span&gt;)
) { buffer, count
    &lt;span class=&quot;keyword variable&quot;&gt;let&lt;&#x2f;span&gt; length = &lt;span class=&quot;support class&quot;&gt;GetCurrentWorkingDirectoryW&lt;&#x2f;span&gt;(
        &lt;span class=&quot;support class&quot;&gt;DWORD&lt;&#x2f;span&gt;(&lt;span class=&quot;support class&quot;&gt;MAX_PATH&lt;&#x2f;span&gt;),
        buffer&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;baseAddress &lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; C API writes in the allocated memory&lt;&#x2f;span&gt;
    )

    count = length &lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; you are responsible for setting size of the array&lt;&#x2f;span&gt;
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Read the steps 1-4 again from earlier, it&#x27;s easy to see how this initializer is
designed to fit that pattern. The resulting array will have all the characters
as its content, and carries the correct size.&lt;&#x2f;p&gt;
&lt;p&gt;When it&#x27;s time to pass the array back to C, we can provide a pointer easily:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;storage&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;withUnsafeBufferPointer {
    &lt;span class=&quot;support class&quot;&gt;SetCurrentDirectory&lt;&#x2f;span&gt;(&lt;span class=&quot;keyword operator&quot;&gt;$&lt;&#x2f;span&gt;&lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;baseAddress&lt;span class=&quot;keyword operator&quot;&gt;!&lt;&#x2f;span&gt;)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This is not great, because we don&#x27;t have a &lt;code&gt;NUL&lt;&#x2f;code&gt; at the end of our array.  The
C function that read our array will sometimes read over the contents memory
until it finds a 0! Yikes.&lt;&#x2f;p&gt;
&lt;p&gt;So here&#x27;s an easy fix:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;(storage + [&lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;])&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;withUnsafeBufferPointer {
    &lt;span class=&quot;support class&quot;&gt;SetCurrentDirectory&lt;&#x2f;span&gt;(&lt;span class=&quot;keyword operator&quot;&gt;$&lt;&#x2f;span&gt;&lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;baseAddress&lt;span class=&quot;keyword operator&quot;&gt;!&lt;&#x2f;span&gt;)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of using the memory of &lt;code&gt;storage&lt;&#x2f;code&gt;, we construct a new array with an 0 as
its last value. This lets C APIs pick the right place to stop reading.
(Incidentally, Swift includes a built-in version of this &lt;a href=&quot;https:&#x2f;&#x2f;developer.apple.com&#x2f;documentation&#x2f;swift&#x2f;string&#x2f;2430818-utf8cstring&quot;&gt;for converting String
to UTF-8 (8-bit) C strings&lt;&#x2f;a&gt;,
which includes the &lt;code&gt;NUL&lt;&#x2f;code&gt; and it&#x27;s possible to further encode with different
encodings.)&lt;&#x2f;p&gt;
&lt;p&gt;Although we&#x27;ve fixed the correctness bug, doing this defeats the purpose of
storing the C string directly somewhat: constructing a new array each time we
want to call a C API is kind of expensive. It involves allocating new memories
and copying over the content, etc.&lt;&#x2f;p&gt;
&lt;p&gt;Alright. How about we carry around the &lt;code&gt;NUL&lt;&#x2f;code&gt; in our array? Let&#x27;s update the
construction code:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;&lt;span class=&quot;keyword variable&quot;&gt;let&lt;&#x2f;span&gt; storage = &lt;span class=&quot;support class&quot;&gt;ContiguousArray&lt;&#x2f;span&gt;(
    &lt;span class=&quot;variable parameter&quot;&gt;unsafeUninitializedCapacity&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;Int&lt;&#x2f;span&gt;(&lt;span class=&quot;support class&quot;&gt;MAX_PATH&lt;&#x2f;span&gt;) + &lt;span class=&quot;constant numeric decimal&quot;&gt;1&lt;&#x2f;span&gt;
) { buffer, count
    &lt;span class=&quot;keyword variable&quot;&gt;let&lt;&#x2f;span&gt; length = &lt;span class=&quot;support class&quot;&gt;GetCurrentWorkingDirectoryW&lt;&#x2f;span&gt;(
        &lt;span class=&quot;support class&quot;&gt;DWORD&lt;&#x2f;span&gt;(&lt;span class=&quot;support class&quot;&gt;MAX_PATH&lt;&#x2f;span&gt;),
        buffer&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;baseAddress
    )

    buffer[length] = &lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;
    count = length + &lt;span class=&quot;constant numeric decimal&quot;&gt;1&lt;&#x2f;span&gt;
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We add 1 every time we have a say in size. Then we manually set a 0 at the end
of the stuff from C. Having done this, we&#x27;ve solved both the correctness problem
and performance concern from earlier!&lt;&#x2f;p&gt;
&lt;p&gt;The last bit of of this journey is ergonomics. Carrying an extra &lt;code&gt;NUL&lt;&#x2f;code&gt; is fine
if you never look at the array&#x27;s content. But when you do, it&#x27;s important to
remember that the content we care about is &lt;em&gt;almost&lt;&#x2f;em&gt; all of the array, except for
the &lt;code&gt;NUL&lt;&#x2f;code&gt; at the end. In other words, simply don&#x27;t make off-by-1 mistakes and
everything will be fine.&lt;&#x2f;p&gt;
&lt;p&gt;Alright, that&#x27;s easier said than done. To alleviate this off-by-1 painfulness,
I ended up exposing a &amp;quot;view&amp;quot; into the array storage that excludes the last
element. Here&#x27;s the actual definition in &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;dduan&#x2f;Pathos&quot;&gt;Pathos&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;span class=&quot;source swift&quot;&gt;&lt;span class=&quot;entity name type&quot;&gt;&lt;span class=&quot;keyword entity&quot;&gt;struct&lt;&#x2f;span&gt; &lt;span class=&quot;entity name type&quot;&gt;&lt;span class=&quot;support class&quot;&gt;CString&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span class=&quot;support class&quot;&gt;Unit&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;BinaryInteger&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;Equatable&lt;&#x2f;span&gt;, &lt;span class=&quot;support class&quot;&gt;Hashable&lt;&#x2f;span&gt; {
    &lt;span class=&quot;storage modifier&quot;&gt;private&lt;&#x2f;span&gt; &lt;span class=&quot;keyword variable&quot;&gt;var&lt;&#x2f;span&gt; &lt;span class=&quot;variable parameter&quot;&gt;storage&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;ContiguousArray&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span class=&quot;support class&quot;&gt;Unit&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;
    &lt;span class=&quot;keyword variable&quot;&gt;var&lt;&#x2f;span&gt; &lt;span class=&quot;variable parameter&quot;&gt;content&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;ContiguousArray&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span class=&quot;support class&quot;&gt;Unit&lt;&#x2f;span&gt;&amp;gt;.&lt;span class=&quot;constant language enum&quot;&gt;SubSequence&lt;&#x2f;span&gt; {
        storage[&lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt; ..&amp;lt; storage&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;count - &lt;span class=&quot;constant numeric decimal&quot;&gt;1&lt;&#x2f;span&gt;]
    }

    &lt;span class=&quot;storage modifier&quot;&gt;public&lt;&#x2f;span&gt; &lt;span class=&quot;storage type function&quot;&gt;func&lt;&#x2f;span&gt; &lt;span class=&quot;entity name function&quot;&gt;&lt;span class=&quot;variable function&quot;&gt;c&lt;&#x2f;span&gt;&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span class=&quot;support class&quot;&gt;T&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;(
        &lt;span class=&quot;variable parameter&quot;&gt;action&lt;&#x2f;span&gt;: (&lt;span class=&quot;support class&quot;&gt;UnsafePointer&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span class=&quot;support class&quot;&gt;Unit&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;) &lt;span class=&quot;keyword control&quot;&gt;throws&lt;&#x2f;span&gt; -&amp;gt; &lt;span class=&quot;support class&quot;&gt;T&lt;&#x2f;span&gt;) &lt;span class=&quot;keyword control&quot;&gt;throws&lt;&#x2f;span&gt; -&amp;gt; &lt;span class=&quot;support class&quot;&gt;T&lt;&#x2f;span&gt;
    {
        &lt;span class=&quot;keyword control&quot;&gt;try&lt;&#x2f;span&gt; content&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;withUnsafeBufferPointer {
            &lt;span class=&quot;keyword control&quot;&gt;try&lt;&#x2f;span&gt; action(&lt;span class=&quot;keyword operator&quot;&gt;$&lt;&#x2f;span&gt;&lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;baseAddress&lt;span class=&quot;keyword operator&quot;&gt;!&lt;&#x2f;span&gt;)
        }
    }

    &lt;span class=&quot;meta function&quot;&gt;&lt;span class=&quot;meta toc-list&quot;&gt;&lt;span class=&quot;storage type function&quot;&gt;init&lt;&#x2f;span&gt;(&lt;span class=&quot;variable parameter&quot;&gt;cString&lt;&#x2f;span&gt;: &lt;span class=&quot;support class&quot;&gt;UnsafePointer&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span class=&quot;support class&quot;&gt;Unit&lt;&#x2f;span&gt;&lt;span class=&quot;keyword operator&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;)&lt;&#x2f;span&gt;&lt;&#x2f;span&gt; {
       &lt;span class=&quot;keyword variable&quot;&gt;var&lt;&#x2f;span&gt; length = &lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;
       &lt;span class=&quot;keyword control&quot;&gt;while&lt;&#x2f;span&gt; cString&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;advanced(&lt;span class=&quot;variable parameter&quot;&gt;by&lt;&#x2f;span&gt;: length)&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;pointee != &lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt; {
           length += &lt;span class=&quot;constant numeric decimal&quot;&gt;1&lt;&#x2f;span&gt;
       }

       storage = &lt;span class=&quot;support class&quot;&gt;ContiguousArray&lt;&#x2f;span&gt;(
           &lt;span class=&quot;variable parameter&quot;&gt;unsafeUninitializedCapacity&lt;&#x2f;span&gt;: length + &lt;span class=&quot;constant numeric decimal&quot;&gt;1&lt;&#x2f;span&gt;
       ) { buffer, count &lt;span class=&quot;keyword control&quot;&gt;in&lt;&#x2f;span&gt;
           &lt;span class=&quot;keyword control&quot;&gt;for&lt;&#x2f;span&gt; offset &lt;span class=&quot;keyword control&quot;&gt;in&lt;&#x2f;span&gt; &lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt; ..&amp;lt; length {
               buffer[offset] = cString&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;advanced(&lt;span class=&quot;variable parameter&quot;&gt;by&lt;&#x2f;span&gt;: offset)&lt;span class=&quot;keyword operator&quot;&gt;.&lt;&#x2f;span&gt;pointee
           }

           buffer[length] = &lt;span class=&quot;constant numeric decimal&quot;&gt;0&lt;&#x2f;span&gt;
           count = length + &lt;span class=&quot;constant numeric decimal&quot;&gt;1&lt;&#x2f;span&gt;
       }
    }

    &lt;span class=&quot;comment line&quot;&gt;&lt;span class=&quot;punctuation definition comment&quot;&gt;&#x2f;&#x2f;&lt;&#x2f;span&gt; ... more stuff&lt;&#x2f;span&gt;
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;code&gt;storage&lt;&#x2f;code&gt; in this solution is an private implementation detail. &lt;code&gt;content&lt;&#x2f;code&gt; is
the primary access to the content of the string. And finally, this type
interops with C APIs correctly and efficiently because of the extra &lt;code&gt;NUL&lt;&#x2f;code&gt; we put
at the end of &lt;code&gt;storage&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
</description>
                <pubDate>Wed, 09 Sep 2020 01:21:26 -0700</pubDate>
                <link>https://duan.ca/2020/09/09/free-c-strings/</link>
                <guid isPermaLink="true">https://duan.ca/2020/09/09/free-c-strings/</guid>
            </item>
    </channel>
</rss>