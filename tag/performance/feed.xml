<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About Performance</title>
        <link>https://duan.ca/tag/performance/</link>
        <atom:link href="https://duan.ca/tag/performance/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>TOMLDecoder 0.4 is 800% Faster</title>
                <description>&lt;p&gt;I just released version 0.4.1 of TOMLDecoder,
a TOML 1.0 parser,
and &lt;a href=&quot;https://developer.apple.com/documentation/swift/codable&quot;&gt;decoder&lt;/a&gt; implemented in pure Swift.
When decoding a TOMLDocument such as &lt;a href=&quot;https://github.com/dduan/TOMLDecoder/blob/cea8f0bee33f37e0fcc33b566a742485c71196e7/Sources/Resources/fixtures/twitter.toml&quot;&gt;this twitter payload&lt;/a&gt;,
TOMLDecoder 0.4.1 is roughly 800% faster by wall clock time than 0.3.x.
In this post, Iâ€™ll discuss how this was achieved.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tl;dr: among other things,
the gains comes from making the parsing algorithm lazier,
and eliminating overheads from bound checking when accessing substrings.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;The Benchmark&lt;/h2&gt;
&lt;p&gt;TOMLDecoder now includes benchmarks implemented with &lt;a href=&quot;https://github.com/ordo-one/package-benchmark&quot;&gt;ordo-one/package-benchmark&lt;/a&gt;.
I plotted the median from the aforementioned benchmark results below.
Each chart includes data points for deserializing the TOML document,
and decoding it on top.
(Unsurprisingly, decoding takes a bit longer.)&lt;/p&gt;
&lt;p&gt;The results show
wall clock time,
CPU instructions,
as well as retain count all trending down significantly.&lt;/p&gt;
&lt;p&gt;In addition to the before and after,
there&#x27;s an extra data point measured specifically prior to adopting Swift&#x27;s &lt;code&gt;Span&lt;/code&gt;.
More on that later.&lt;/p&gt;
&lt;iframe id=&quot;benchmark-iframe&quot; src=&quot;/assets/2025/12/tomldecoder-0.4.0-benchmark-charts.html&quot; width=&quot;100%&quot; height=&quot;1200&quot; frameborder=&quot;0&quot; style=&quot;border: none; display: block; margin: 20px 0; min-height: 1200px;&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
window.addEventListener(&#x27;message&#x27;, function(event) {
    if (event.data.type === &#x27;resize&#x27;) {
        const iframe = document.getElementById(&#x27;benchmark-iframe&#x27;);
        if (iframe) {
            iframe.style.height = event.data.height + &#x27;px&#x27;;
            iframe.style.transition = &#x27;none&#x27;;
        }
    }
});
&lt;/script&gt;
&lt;h2&gt;How to make a parser go fast&lt;/h2&gt;
&lt;h3&gt;Improving data structure and algorithms&lt;/h3&gt;
&lt;p&gt;... also known as cheating.
Yes, really.&lt;/p&gt;
&lt;p&gt;In 0.3.x, &lt;code&gt;TOMLDecoder&lt;/code&gt; behaves like &lt;a href=&quot;https://developer.apple.com/documentation/foundation/jsonserialization&quot;&gt;JSONSerialization&lt;/a&gt;.
When you ask it to decode TOML data,
with &lt;code&gt;TOMLDecoder.tomlTable(from:)&lt;/code&gt;
it goes through the entire document,
creates matching container structures within it.
For each TOML table, it creates a &lt;code&gt;[String: Any]&lt;/code&gt;,
for each TOML array, it creates a &lt;code&gt;[Any]&lt;/code&gt;.
When a table contains an array,
for example,
a corresponding &lt;code&gt;[&amp;quot;key&amp;quot;: [...]]&lt;/code&gt; entry is created to match.
Along the way, the parser also validates the leaf types,
so things like a ill-formed date causes an error to be thrown.
The end result is a &lt;code&gt;[String: Any]&lt;/code&gt; in which
everything is known to be valid.&lt;/p&gt;
&lt;p&gt;A number of things are slow in this process:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The frequent creation and subsequent usage of intermediary Swift arrays and dictionaries require heap allocations.&lt;/li&gt;
&lt;li&gt;Validating every leaf value takes time.&lt;/li&gt;
&lt;li&gt;Retrieved values are &lt;code&gt;Any&lt;/code&gt;s, so you have to cast it to the expected type to consume them.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TOMLDecoder 0.4 does away with all of that.&lt;/p&gt;
&lt;p&gt;To represent the containers,
and leaf values,
0.4 introduces some light-weight structs,
These structs don&#x27;t manage the actual memory used to store their contents.
As the parser work through the bytes of a TOML document,
it creates these light weight data types to record the shape of the document,
as well as the byte-offsets of the leaf values.
These intermediary data are stored in a centralized location
to avoid unnecessary heap allocations.&lt;/p&gt;
&lt;p&gt;Here&#x27;s what I mean by &amp;quot;cheating&amp;quot;:
during this phase,
the parser doesn&#x27;t do much validation of the leaf values.
What it does is more akin to &amp;quot;lexing&amp;quot;,
it finds the tokens that could represent a leaf value,
and remembers where they are.
No work is done to actually validate and create the leaf values.&lt;/p&gt;
&lt;p&gt;To retrieve any values from the result,
you must state what type is expected:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;// a valid TOML document is always a table at the root level
let serverIP = try TOMLTable(source: tomlString)
	.string(forKey: &amp;quot;ip&amp;quot;) // validate this token as a `String`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is an API change.
It delays the validation work,
and helps avoid conversions from &lt;code&gt;Any&lt;/code&gt;.
If you only need one field,
no validation is necessary on the rest of the leaf values in the entire document.&lt;/p&gt;
&lt;p&gt;Swift&#x27;s decoding APIs ask for typed access:
if your &lt;code&gt;Codable&lt;/code&gt; type has a &lt;code&gt;Date&lt;/code&gt; field,
you ask the container for a &lt;code&gt;Date&lt;/code&gt;,
if the matching value at the spot is of a different type,
an error is thrown.
So the more efficient access pattern benefits the decoding process as well.&lt;/p&gt;
&lt;h3&gt;Avoiding bound checks&lt;/h3&gt;
&lt;p&gt;A major source of slowness in TOMLDecoder 0.3.x is the cost of bound checks in Swift.
The parser holds a reference to the original string,
and hands &lt;code&gt;Substring&lt;/code&gt;s to small functions to descend on.
A typical piece of the parser might look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func skipWhitespaces(_ text: inout Substring) {
    let bytes = text.utf8
    var i = bytes.startIndex
    while i &amp;lt; bytes.endIndex {
        if !isWhitespace(bytes[i]) { // bound checks!
            break
        }
        bytes.formIndex(after: &amp;amp;i)
    }
    text = Substring(bytes[i...])
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To avoid out-of-bound access,
Swift inserts logic that checks the validity of the index
for every subscript access of the string&#x27;s buffer.
A parser does a whole lot of that.
The cost of these bound checks seriously adds up.&lt;/p&gt;
&lt;p&gt;Since the release of TOMLDecoder 0.3.0,
Swift has gained a whole set of features that led to the introduction of &lt;a href=&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0447-span-access-shared-contiguous-storage.md&quot;&gt;Span&lt;/a&gt;.
&lt;code&gt;Span&lt;/code&gt; is built on compile-time lifetime checks.
These checks guarantee the safety when accessing its content.
The same function updated for &lt;code&gt;Span&lt;/code&gt; looks extremely similar to the original:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func skipWhitespace(
    bytes: Span&amp;lt;UTF8.CodeUnit&amp;gt;, // aka Span&amp;lt;UInt8&amp;gt;
    remainingBytes: inout Range&amp;lt;Int&amp;gt;,
) {
    var i = remainingBytes.lowerBound
    while i &amp;lt; bytes.count {
        if !isWhitespace(bytes[i]) { break }
        i += 1
    }
    remainingBytes = i ..&amp;lt; remainingBytes.upperBound
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here,
the subscript access of &lt;code&gt;bytes&lt;/code&gt; does not incur a bound check!
This created significant performance gains as shown in the benchmark results.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Here&#x27;s the kicker&lt;/em&gt;.
The bound checks are eliminated
because the compiler is confident that the access is safe by construction.
If you make a mistake that would lead to unsafe access,
Swift will refuse to compile your code.
But &lt;code&gt;Span&lt;/code&gt; is a language feature that requires new language runtime.
You cannot use it on older operating systems.
There&#x27;s other, older ways to avoid bound checks,
using &lt;code&gt;UnsafeBufferPointer&lt;/code&gt;s.
The problem of doing so is that you are responsible for ensuring that the access is safe.
In particular, the point of access must occur in a valid scope for the pointer.
A piece of parser using such API may look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func skipWhitespace(
    bytes: UnsafeBufferPointer&amp;lt;UTF8.CodeUnit&amp;gt;,
    remainingBytes: inout Range&amp;lt;Int&amp;gt;,
) {
    var i = remainingBytes.lowerBound
    while i &amp;lt; bytes.count {
        if !isWhitespace(bytes[i]) { break }
        i += 1
    }
    remainingBytes = i ..&amp;lt; remainingBytes.upperBound
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But WAIT!  This code using the buffer pointer look extremely similar to the &lt;code&gt;Span&lt;/code&gt; version!
And if you think carefully,
the requirement for maintaining valid scope for the &lt;code&gt;UnsafeBufferPointer&lt;/code&gt; is already &lt;em&gt;enforced&lt;/em&gt; for any &lt;code&gt;Span&lt;/code&gt;s, syntactically!&lt;/p&gt;
&lt;p&gt;Enter &lt;a href=&quot;https://nshipster.com/swift-gyb/&quot;&gt;gyb&lt;/a&gt;. A script that Swift uses to generate repetitive code in the complier.
In TOMLDecoder 0.4,
the parser implementation uses it to generate 2 version of the same set of parsing logic:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;configs = [
    (&amp;quot;Span&amp;lt;UInt8&amp;gt;&amp;quot;, &amp;quot;@available(iOS 26, macOS 26, watchOS 26, tvOS 26, visionOS 26, *)&amp;quot;),
    (&amp;quot;UnsafeBufferPointer&amp;lt;UInt8&amp;gt;&amp;quot;, &amp;quot;@available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, visionOS 1, *)&amp;quot;),
]
}%
% for byte_type, availability in configs:
${availability}
func parse(bytes: ${byte_type}) throws -&amp;gt; TOMLTable {
	// same code
}
% end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... and there&#x27;s a single place that checks for the OS at runtime:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;let source: String = // TOML string
    if #available(iOS 26, macOS 26, watchOS 26, tvOS 26, visionOS 26, *) {
        let bytes = source.utf8Span.span
        try parse(bytes: bytes)
    } else {
        try source.withUTF8 { try parse(bytes: $0) }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The beauty here,
is that the compiler does all the work to ensure the access to the &lt;code&gt;Span&lt;/code&gt;
as well as the buffer pointer are safe,
because the logic that does the accessing are identical thanks to &lt;code&gt;gyb&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In reality, there are a ton of other optimizations applied in TOMLDecoder 0.4.
For example,
instead of doing dictionary look ups,
looking up things from a TOMLDocument actually involves a linear search.
I know, I know, this goes against what we were taught in CS.
But in modern computers,
and for typical sizes of TOML documents,
a linear search is often faster that computing a hash value,
and the subsequent lookups.&lt;/p&gt;
&lt;p&gt;As part of the release,
the project also gained a bunch of infra improvements.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It has a &lt;a href=&quot;https://www.swift.org/documentation/docc/&quot;&gt;DocC&lt;/a&gt;-based &lt;a href=&quot;https://dduan.github.io/TOMLDecoder/main/documentation/tomldecoder/&quot;&gt;documentation site&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The entirety of the &lt;a href=&quot;https://github.com/toml-lang/toml-test&quot;&gt;official test suite&lt;/a&gt; is now programmatically imported as unit tests.&lt;/li&gt;
&lt;li&gt;The source code style is now enforced by &lt;a href=&quot;https://github.com/nicklockwood/SwiftFormat&quot;&gt;swiftformat&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Platform checks are more comprehensive and modern on CI.&lt;/li&gt;
&lt;li&gt;Benchmarks are now modernized with &lt;a href=&quot;https://github.com/ordo-one/package-benchmark&quot;&gt;ordo-one/package-benchmark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I think of this release as a preparation for a eventual 1.0 release,
which will support the &lt;a href=&quot;https://forums.swift.org/t/the-future-of-serialization-deserialization-apis/78585/171&quot;&gt;new deserialization APIs from Swift&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Even through I went through some optimizations for speed in this post,
I still have a bunch of ideas I want to try to squeeze out more performance gains.
That&#x27;s exciting.&lt;/p&gt;
</description>
                <pubDate>Wed, 10 Dec 2025 17:44:34 -0800</pubDate>
                <link>https://duan.ca/2025/12/10/TOMLDecoder-0.4.1/</link>
                <guid isPermaLink="true">https://duan.ca/2025/12/10/TOMLDecoder-0.4.1/</guid>
            </item>
    </channel>
</rss>