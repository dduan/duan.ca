<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About Python</title>
        <link>https://duan.ca/tag/python/</link>
        <atom:link href="https://duan.ca/tag/python/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>List Comprehension In Swift</title>
                <description>&#60;p&#62;Let&#39;s explore ways to add list comprehension to Swift.&#60;/p&#62;
&#60;h2&#62;Motivation&#60;/h2&#62;
&#60;p&#62;&#60;a href=&#34;https://en.wikipedia.org/wiki/List_comprehension&#34;&#62;List comprehension&#60;/a&#62; should be no stranger to a Python or (and?) Haskell user. It&#39;s a really compact syntax
that deals with &#60;a href=&#34;https://en.wikipedia.org/wiki/Cartesian_product&#34;&#62;Cartesian product&#60;/a&#62; of lists. In the case of Python, it&#39;s probably responsible for the lack
of evolution of lambda expressions, since it&#39;s much nicer to write one-liners with it in place of &#60;code&#62;map&#60;/code&#62;s and
&#60;code&#62;filter&#60;/code&#62;s.&#60;/p&#62;
&#60;p&#62;Here&#39;s an example of an list comprehension in Haskell from Wikipedia:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-haskell&#34;&#62;a = [(x,y) | x &#38;lt;- [1..5], y &#38;lt;- [3..5]]
-- [(1,3),(1,4),(1,5),(2,3),(2,4) ...
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;In this example, a list of pair of integers is constructed from 2 lists of integers.&#60;/p&#62;
&#60;p&#62;Here is what that example would be in Python:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-python&#34;&#62;a = [(x, y) for x in range(1,6) for y in range(3, 6)]
# [(1, 3), (1, 4), (1, 5), (2, 3), (2, 4) ...
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Here&#39;s what it would be in mathematics (except we are dealing with sets, not lists, but I&#39;ll only refer to
lists from here on.):&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;Let (a, b) be an ordered list of elements

{(x, y)|x ∈ {1,2,3,4,5}, y ∈ {3,4,5}}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;One can filter out unwanted elements with predicates, and apply arbitrary functions to elements of the
result. Let&#39;s say we only want even numbers from the first list, and we want the sum of x and y, continuing on
our examples:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-haskell&#34;&#62;a = [x+y | x &#38;lt;- [1..5], y &#38;lt;- [3..5], x `mod` 2 == 0]
&#60;/code&#62;&#60;/pre&#62;
&#60;pre&#62;&#60;code class=&#34;language-python&#34;&#62;a = [x + y for x in range(1,6) for y in range(3, 6) if x % 2 == 0]
&#60;/code&#62;&#60;/pre&#62;
&#60;pre&#62;&#60;code&#62;{x+y|x ∈ {1,2,3,4,5}, y ∈ {3,4,5}, x is even}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;In theory, this syntax can be applied to an arbitrary number of lists. Putting aside how often this need comes
up in day-to-day programming in your domain, it should be obvious that it&#39;s alternative, be it nested loops or
&#60;code&#62;map&#60;/code&#62;s and &#60;code&#62;filter&#60;/code&#62;s, is pretty clumsy in comparison.&#60;/p&#62;
&#60;h2&#62;Adding List Comprehension in Swift&#60;/h2&#62;
&#60;p&#62;A comprehension can be considered in 3 parts:&#60;/p&#62;
&#60;ol&#62;
&#60;li&#62;some lists, each may contain a different type of elements.&#60;/li&#62;
&#60;li&#62;a predicate (or a series of them joined logically) to filter out elements.&#60;/li&#62;
&#60;li&#62;a function to process the combination of elements into results.&#60;/li&#62;
&#60;/ol&#62;
&#60;p&#62;In Swift, if our input is only one list, there&#39;s a pretty sweet way to achieve that:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;list.filter(predicate).map(processor)
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;To make comprehension work with more lists, we have some syntax options.&#60;/p&#62;
&#60;h3&#62;Option One&#60;/h3&#62;
&#60;p&#62;The &#38;quot;brute force&#38;quot; option would be a function that parameterize all 3 parts of the comprehension. Such as&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;// going with order of appearance in Python/Haskell syntax
func comprehension&#38;lt;Element, List, Result&#38;gt;(
    predicate: (Element) -&#38;gt; Bool,
    list: List,
    processor: (Element) -&#38;gt; Result
) where
    List: Sequence, List.Element == Element

{
    // implementation
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;To supporting more than one list, just add more parameters to both types and the function itself.&#60;/p&#62;
&#60;p&#62;(Can&#39;t wait until we can have &#60;a href=&#34;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#variadic-generics&#34;&#62;variadic generic parameters&#60;/a&#62;!)&#60;/p&#62;
&#60;h3&#62;Option Two&#60;/h3&#62;
&#60;p&#62;Deploy more syntax tricks. Somehow make it visually similar to the math/Haskell/Python notation. If we can
accept some temporary data structure and introduce/implement some operators, there&#39;d be many possibilities.&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;/// Just an example of the infinite possibilities.
processor | list0 &#38;amp;&#38;amp;&#38;amp; list1 | predicate
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;I&#39;ll leave the implementation of this example as an exercise to the reader.&#60;/p&#62;
&#60;h3&#62;Option That I Like&#60;/h3&#62;
&#60;p&#62;I spent quite some time exploring the realm of possibilities in &#38;quot;option two&#38;quot;. However, introducing data
structures and custom operators just to do what &#38;quot;option one&#38;quot; offers seems really unappealing. It&#39;s not
entirely clear that doing so would be &#38;quot;Swift-y&#38;quot; anyways! Eventually, I did find an arrangement that fits in
Swift, and requires no fancy syntax trickery.&#60;/p&#62;
&#60;p&#62;The result of list comprehension is a list. The goal of this operation is to &#60;em&#62;construct&#60;/em&#62; a list. Yep, thinking
along this line, it became obvious that using a &#38;quot;list&#38;quot;&#39;s initializer is just natural:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;let a = Array(1..&#38;lt;5, 3..&#38;lt;5, where: { n, _ in n % 2 == 0 }) { ($0, $1) }
// [(2,3),(2,4),(2,5) ...
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;The processing function is at the end to take advantage of the trailing closure syntax. It&#39;s nicer when
there&#39;s not predicate:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;let a = Array(1..&#38;lt;5, 3..&#38;lt;5) { ($0, $1) }
// [(1,3),(1,4),(1,5),(2,3),(2,4) ...
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;This syntax seems both succinct and Swift-y.&#60;/p&#62;
&#60;p&#62;I put an implementation on &#60;a href=&#34;https://github.com/dduan/Comprehension&#34;&#62;github&#60;/a&#62;, in case you find it useful.&#60;/p&#62;
&#60;h2&#62;Parting Thoughts&#60;/h2&#62;
&#60;p&#62;There&#39;s no doubt that the conclusion in this post is imperfect. Though it feels more Swift-y, it deviates from
the mathematical syntax by a lot. We can only implement it for finite number of lists. When many lists are
involved, using a embedded closure as the predicate would make the compiler complain that the expression is
too complex. We suffer from the normal woes with Swift closures where anonymous arguments (&#60;code&#62;$0&#60;/code&#62;, &#60;code&#62;$1&#60;/code&#62;, etc)
won&#39;t work unless the last one is mentioned in the closure&#39;s body. Overloading &#60;code&#62;Array&#60;/code&#62; initializer may
negatively affect compilation speed in large projects.&#60;/p&#62;
&#60;p&#62;Not all of these issues are temporary.&#60;/p&#62;
&#60;p&#62;Does list comprehension warrant a language change in Swift? Can you think of better ways to implement it
with the current compiler?&#60;/p&#62;
</description>
                <pubDate>Sat, 09 Dec 2017 12:26:30 -0800</pubDate>
                <link>https://duan.ca/2017/12/09/list-comprehension-in-swift/</link>
                <guid isPermaLink="true">https://duan.ca/2017/12/09/list-comprehension-in-swift/</guid>
            </item>
            <item>
                <title>A Case For OOP?</title>
                <description>&#60;p&#62;Python&#39;s standard library includes a very handy &#60;code&#62;defaultdict&#60;/code&#62;. It behaves
almost exactly like the standard dictionary except it&#39;ll supply a pre-defined
value for any non-existence keys. It is, unsurpringly, a subclass of &#60;code&#62;dict&#60;/code&#62;.&#60;/p&#62;
&#60;p&#62;I find my self missing this handy container in Swift. Especially when I use
a normal &#60;code&#62;Dictionary&#60;/code&#62; to accumulate/coalesce values under distinct keys. So I
wrote my own:&#60;/p&#62;
&#60;script src=&#34;https://gist.github.com/dduan/31ed39c4c98ecb88290f0743cb394c20.js&#34;&#62;&#60;/script&#62;
&#60;p&#62;There are a few noticable things about this implementation:&#60;/p&#62;
&#60;ul&#62;
&#60;li&#62;It does not conform to the &#60;code&#62;DictionaryLiteralConvertible&#60;/code&#62; protocol, for no
good reasons, really. The initializer in this protocol takes a varadic
argument. There&#39;s no conevient way to forward this array to a normal
dictionary&#39;s initializer (incidentally, this is a Swift feature I really
want). Plus, I don&#39;t need &#60;code&#62;DefaultDictionary&#60;/code&#62; to be a literal convertible.&#60;/li&#62;
&#60;li&#62;Most of the code, including the imaginary &#60;code&#62;init&#60;/code&#62; mentioned in previous
point, simply reuses stuff from &#60;code&#62;Dictionary&#60;/code&#62;: asscociated type, indexes,
generator, subscript, etc.&#60;/li&#62;
&#60;/ul&#62;
&#60;p&#62;In comparison, Python implements &#60;code&#62;defaultdict&#60;/code&#62; in a more intuitive way -- via
inheritance.&#60;/p&#62;
&#60;p&#62;But do we want inheritance for &#60;code&#62;struct&#60;/code&#62;s and &#60;code&#62;enum&#60;/code&#62;s in Swift? What does that
even mean? Is it simply a case that will go away when protocols become more
powerful?&#60;/p&#62;
</description>
                <pubDate>Thu, 19 May 2016 12:03:02 -0700</pubDate>
                <link>https://duan.ca/2016/05/19/a-case-for-oop/</link>
                <guid isPermaLink="true">https://duan.ca/2016/05/19/a-case-for-oop/</guid>
            </item>
            <item>
                <title>Installing PyQt5 with Python 3 On OS X</title>
                <description>&#60;p&#62;Today I installed PyQt5 on OS X 10.9. Turns out, it&#39;s not as straight-forward
as one would think.&#60;/p&#62;
&#60;p&#62;Using &#60;code&#62;homebrew&#60;/code&#62; will &#60;strong&#62;not&#60;/strong&#62; work:&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;    brew install PyQt5 --with-python3
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;This is because of &#60;a href=&#34;https://github.com/Homebrew/homebrew/issues/25735&#34;&#62;an unfortunate choice&#60;/a&#62; made by the
homebrew maintainer regarding Python 3.&#60;/p&#62;
&#60;p&#62;So installing from &#60;a href=&#34;http://pyqt.sourceforge.net/Docs/PyQt5/installation.html&#34;&#62;source&#60;/a&#62; is the way to go. Following the
installing instruction, you would download and install &#60;a href=&#34;https://web.archive.org/web/20140410074945/http://pyqt.sourceforge.net/Docs/sip4/installation.html&#34;&#62;sip&#60;/a&#62;
first, the install &#60;a href=&#34;http://pyqt.sourceforge.net/Docs/PyQt5/installation.html&#34;&#62;PyQt5&#60;/a&#62; itself.&#60;/p&#62;
&#60;p&#62;Except that&#39;s not enough. When you run &#60;code&#62;python configure.py&#60;/code&#62;, you see this
error:&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;    error: Use the --qmake argument to explicitly specify a working Qt
    qmake.
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;It&#39;s pretty self-explanatory. &#60;code&#62;qmake&#60;/code&#62;, the build tool for qt is needed here.
Install qt5 with homebrew and proceed:&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;    brew install qt5
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Afterwards, you should be able to import &#60;code&#62;PyQt5&#60;/code&#62; in a Python 3 REPL.&#60;/p&#62;
</description>
                <pubDate>Wed, 23 Apr 2014 10:36:00 -0600</pubDate>
                <link>https://duan.ca/2014/04/23/installing-pyqt5-with-python-3-on-os-x/</link>
                <guid isPermaLink="true">https://duan.ca/2014/04/23/installing-pyqt5-with-python-3-on-os-x/</guid>
            </item>
    </channel>
</rss>