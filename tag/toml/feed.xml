<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About TOML</title>
        <link>https://duan.ca/tag/toml/</link>
        <atom:link href="https://duan.ca/tag/toml/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>TOMLDecoder 0.4 is 800% Faster</title>
                <description>&#60;p&#62;I just released version 0.4.1 of &#60;a href=&#34;https://github.com/dduan/TOMLDecoder&#34;&#62;TOMLDecoder&#60;/a&#62;,
a TOML 1.0 parser,
and &#60;a href=&#34;https://developer.apple.com/documentation/swift/codable&#34;&#62;decoder&#60;/a&#62; implemented in pure Swift.
When decoding a TOMLDocument such as &#60;a href=&#34;https://github.com/dduan/TOMLDecoder/blob/cea8f0bee33f37e0fcc33b566a742485c71196e7/Sources/Resources/fixtures/twitter.toml&#34;&#62;this twitter payload&#60;/a&#62;,
TOMLDecoder 0.4.1 is roughly 800% faster by wall clock time than 0.3.x.
In this post, I’ll discuss how this was achieved.&#60;/p&#62;
&#60;p&#62;&#60;em&#62;tl;dr: among other things,
the gains comes from making the parsing algorithm lazier,
and eliminating overheads from bound checking when accessing substrings.&#60;/em&#62;&#60;/p&#62;
&#60;p&#62;&#60;em&#62;Update:
An earlier version of this post claimed that adopting Span eliminates cost of all bound checking
when accessing the underlying bytes of the TOML content,
that turns out to be wrong.
The reality is more interesting.
The post has been revised to discuss what really brought the performance gains
after adopting Span.&#60;/em&#62;&#60;/p&#62;
&#60;h2&#62;The Benchmark&#60;/h2&#62;
&#60;p&#62;TOMLDecoder now includes benchmarks implemented with &#60;a href=&#34;https://github.com/ordo-one/package-benchmark&#34;&#62;ordo-one/package-benchmark&#60;/a&#62;.
I plotted the median from the aforementioned benchmark results below.
Each chart includes data points for deserializing the TOML document,
and decoding it on top.
(Unsurprisingly, decoding takes a bit longer.)&#60;/p&#62;
&#60;p&#62;The results show
wall clock time,
CPU instructions,
as well as retain count all trending down significantly.&#60;/p&#62;
&#60;p&#62;In addition to the before and after,
there&#39;s an extra data point measured specifically prior to adopting Swift&#39;s &#60;code&#62;Span&#60;/code&#62;.
More on that later.&#60;/p&#62;
&#60;iframe id=&#34;benchmark-iframe&#34; src=&#34;/assets/2025/12/tomldecoder-0.4.0-benchmark-charts.html&#34; width=&#34;100%&#34; height=&#34;1200&#34; frameborder=&#34;0&#34; style=&#34;border: none; display: block; margin: 20px 0; min-height: 1200px;&#34;&#62;&#60;/iframe&#62;
&#60;script&#62;
window.addEventListener(&#39;message&#39;, function(event) {
    if (event.data.type === &#39;resize&#39;) {
        const iframe = document.getElementById(&#39;benchmark-iframe&#39;);
        if (iframe) {
            iframe.style.height = event.data.height + &#39;px&#39;;
            iframe.style.transition = &#39;none&#39;;
        }
    }
});
&#60;/script&#62;
&#60;h2&#62;How to make a parser go fast&#60;/h2&#62;
&#60;h3&#62;Improving data structure and algorithms&#60;/h3&#62;
&#60;p&#62;... also known as cheating.
Yes, really.&#60;/p&#62;
&#60;p&#62;In 0.3.x, &#60;code&#62;TOMLDecoder&#60;/code&#62; behaves like &#60;a href=&#34;https://developer.apple.com/documentation/foundation/jsonserialization&#34;&#62;JSONSerialization&#60;/a&#62;.
When you ask it to decode TOML data,
with &#60;code&#62;TOMLDecoder.tomlTable(from:)&#60;/code&#62;
it goes through the entire document,
creates matching container structures within it.
For each TOML table, it creates a &#60;code&#62;[String: Any]&#60;/code&#62;,
for each TOML array, it creates a &#60;code&#62;[Any]&#60;/code&#62;.
When a table contains an array,
for example,
a corresponding &#60;code&#62;[&#38;quot;key&#38;quot;: [...]]&#60;/code&#62; entry is created to match.
Along the way, the parser also validates the leaf types,
so things like a ill-formed date causes an error to be thrown.
The end result is a &#60;code&#62;[String: Any]&#60;/code&#62; in which
everything is known to be valid.&#60;/p&#62;
&#60;p&#62;A number of things are slow in this process:&#60;/p&#62;
&#60;ul&#62;
&#60;li&#62;The frequent creation and subsequent usage of intermediary Swift arrays and dictionaries require heap allocations.&#60;/li&#62;
&#60;li&#62;Validating every leaf value takes time.&#60;/li&#62;
&#60;li&#62;Retrieved values are &#60;code&#62;Any&#60;/code&#62;s, so you have to cast it to the expected type to consume them.&#60;/li&#62;
&#60;/ul&#62;
&#60;p&#62;TOMLDecoder 0.4 does away with all of that.&#60;/p&#62;
&#60;p&#62;To represent the containers,
and leaf values,
0.4 introduces some light-weight structs,
These structs don&#39;t manage the actual memory used to store their contents.
As the parser work through the bytes of a TOML document,
it creates these light weight data types to record the shape of the document,
as well as the byte-offsets of the leaf values.
These intermediary data are stored in a centralized location
to avoid unnecessary heap allocations.&#60;/p&#62;
&#60;p&#62;Here&#39;s what I mean by &#38;quot;cheating&#38;quot;:
during this phase,
the parser doesn&#39;t do much validation of the leaf values.
What it does is more akin to &#38;quot;lexing&#38;quot;,
it finds the tokens that could represent a leaf value,
and remembers where they are.
No work is done to actually validate and create the leaf values.&#60;/p&#62;
&#60;p&#62;To retrieve any values from the result,
you must state what type is expected:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;// a valid TOML document is always a table at the root level
let serverIP = try TOMLTable(source: tomlString)
	.string(forKey: &#38;quot;ip&#38;quot;) // validate this token as a `String`
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;This is an API change.
It delays the validation work,
and helps avoid conversions from &#60;code&#62;Any&#60;/code&#62;.
If you only need one field,
no validation is necessary on the rest of the leaf values in the entire document.&#60;/p&#62;
&#60;p&#62;Swift&#39;s decoding APIs ask for typed access:
if your &#60;code&#62;Codable&#60;/code&#62; type has a &#60;code&#62;Date&#60;/code&#62; field,
you ask the container for a &#60;code&#62;Date&#60;/code&#62;,
if the matching value at the spot is of a different type,
an error is thrown.
So the more efficient access pattern benefits the decoding process as well.&#60;/p&#62;
&#60;h3&#62;Eliminating bound checks&#60;/h3&#62;
&#60;p&#62;A major source of slowness in TOMLDecoder 0.3.x
comes from inefficient patterns when the underyling bytes of a TOML document.&#60;/p&#62;
&#60;p&#62;The parser holds a reference to the original string,
and hands &#60;code&#62;String.UTF8View.SubSequence&#60;/code&#62;s to small functions to descend on.
A typical piece of the parser might look like this:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;func skipWhitespaces(_ text: inout String.UTF8View.SubSequence) {
    let bytes = text.utf8
    var i = bytes.startIndex
    while i &#38;lt; bytes.endIndex {
        if !isWhitespace(bytes[i]) { // very slow!
            break
        }
        bytes.formIndex(after: &#38;amp;i)
    }
    text = bytes[i...]
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Using UTF8View makes sure that we aren&#39;t dealing with &#60;code&#62;Character&#60;/code&#62;s,
which could have variable lengths.
However,
accessing the bytes in this way introduces multiple rounds of bound checks
that ends up being super expensive in the hot path of the parser:&#60;/p&#62;
&#60;ol&#62;
&#60;li&#62;The standard library needs to check that a index is valid for the &#60;code&#62;SubSequence&#60;/code&#62; aka &#60;code&#62;Substring&#60;/code&#62;
by comparing it against the start and end indices.&#60;/li&#62;
&#60;li&#62;Then, the index is used to access the underlying &#60;code&#62;UTF8View&#60;/code&#62;, at this point,
the standard library checks whether the index is out of bound again.&#60;/li&#62;
&#60;li&#62;A the end, the library goes into the buffer pointer of the string to retrieve the actual byte.&#60;/li&#62;
&#60;/ol&#62;
&#60;p&#62;(All of that assumes that the string&#39;s buffer is contiguously stored in memory.
There&#39;s a even slower path that I could eliminate by ensuring the string is native.)&#60;/p&#62;
&#60;p&#62;A parser does a whole lot of such accesses.
The cost of these bound checks seriously adds up.&#60;/p&#62;
&#60;p&#62;Since the release of TOMLDecoder 0.3.0,
Swift has gained a whole set of features that led to the introduction of &#60;a href=&#34;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0447-span-access-shared-contiguous-storage.md&#34;&#62;Span&#60;/a&#62;.
&#60;code&#62;Span&#60;/code&#62; is built on compile-time lifetime checks.
These checks guarantee the safety when accessing its content.
The same function updated for &#60;code&#62;Span&#60;/code&#62; looks extremely similar to the original:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;func skipWhitespace(
    bytes: Span&#38;lt;UTF8.CodeUnit&#38;gt;, // aka Span&#38;lt;UInt8&#38;gt;
    remainingBytes: inout Range&#38;lt;Int&#38;gt;,
) {
    var i = remainingBytes.lowerBound
    while i &#38;lt; bytes.count {
        if !isWhitespace(bytes[i]) { break }
        i += 1
    }
    remainingBytes = i ..&#38;lt; remainingBytes.upperBound
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Here,
the subscript access of &#60;code&#62;bytes&#60;/code&#62; does not incur multiple rounds of bound checks!
Rather, it skips step 1,
which eliminates 2 integer comparisons per access,
a 2/3 reduction in bound check overhead.
Further, the compiler can see the access pattern more clearly,
it can heuristically eliminate even the final remaning bound checks in some casse.&#60;/p&#62;
&#60;p&#62;Not having to perform all the bound checks
in the tight loop of the parser results significant performance gains
as shown in the benchmark results.&#60;/p&#62;
&#60;p&#62;&#60;em&#62;Here&#39;s the kicker&#60;/em&#62;.
With &#60;code&#62;Span&#60;/code&#62;,
the bound checks are eliminated
because the compiler is confident that the access is safe by construction.
If you make a mistake that would lead to unsafe access,
Swift will refuse to compile your code.
But &#60;code&#62;Span&#60;/code&#62; is a language feature that requires new language runtime.
You cannot use it on older operating systems.
There&#39;s other, older ways to avoid bound checks,
using &#60;code&#62;UnsafeBufferPointer&#60;/code&#62;s.
The problem of doing so is that you are responsible for ensuring that the access is safe.
In particular, the point of access must occur in a valid scope for the pointer.
A piece of parser using such API may look like this:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;func skipWhitespace(
    bytes: UnsafeBufferPointer&#38;lt;UTF8.CodeUnit&#38;gt;,
    remainingBytes: inout Range&#38;lt;Int&#38;gt;,
) {
    var i = remainingBytes.lowerBound
    while i &#38;lt; bytes.count {
        if !isWhitespace(bytes[i]) { break }
        i += 1
    }
    remainingBytes = i ..&#38;lt; remainingBytes.upperBound
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;But WAIT!  This code using the buffer pointer look extremely similar to the &#60;code&#62;Span&#60;/code&#62; version!
And if you think carefully,
the requirement for maintaining valid scope for the &#60;code&#62;UnsafeBufferPointer&#60;/code&#62; is already &#60;em&#62;enforced&#60;/em&#62; for any &#60;code&#62;Span&#60;/code&#62;s, syntactically!&#60;/p&#62;
&#60;p&#62;Enter &#60;a href=&#34;https://nshipster.com/swift-gyb/&#34;&#62;gyb&#60;/a&#62;. A script that Swift uses to generate repetitive code in the complier.
In TOMLDecoder 0.4,
the parser implementation uses it to generate 2 version of the same set of parsing logic:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;configs = [
    (&#38;quot;Span&#38;lt;UInt8&#38;gt;&#38;quot;, &#38;quot;@available(iOS 26, macOS 26, watchOS 26, tvOS 26, visionOS 26, *)&#38;quot;),
    (&#38;quot;UnsafeBufferPointer&#38;lt;UInt8&#38;gt;&#38;quot;, &#38;quot;@available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, visionOS 1, *)&#38;quot;),
]
}%
% for byte_type, availability in configs:
${availability}
func parse(bytes: ${byte_type}) throws -&#38;gt; TOMLTable {
	// same code
}
% end
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;... and there&#39;s a single place that checks for the OS at runtime:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;let source: String = ... // TOML string
if #available(iOS 26, macOS 26, watchOS 26, tvOS 26, visionOS 26, *) {
    let bytes = source.utf8Span.span
    try parse(bytes: bytes)
} else {
    try source.withUTF8 { try parse(bytes: $0) }
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;The beauty here,
is that the compiler does all the work to ensure the access to the &#60;code&#62;Span&#60;/code&#62;
as well as the buffer pointer are safe,
because the logic that does the accessing are identical thanks to &#60;code&#62;gyb&#60;/code&#62;.&#60;/p&#62;
&#60;h2&#62;Conclusion&#60;/h2&#62;
&#60;p&#62;In reality, there are a ton of other optimizations applied in TOMLDecoder 0.4.
For example,
instead of doing dictionary look ups,
looking up things from a TOMLDocument actually involves a linear search.
I know, I know, this goes against what we were taught in CS.
But in modern computers,
and for typical sizes of TOML documents,
a linear search is often faster that computing a hash value,
and the subsequent lookups.&#60;/p&#62;
&#60;p&#62;As part of the release,
the project also gained a bunch of infra improvements.&#60;/p&#62;
&#60;ul&#62;
&#60;li&#62;It has a &#60;a href=&#34;https://www.swift.org/documentation/docc/&#34;&#62;DocC&#60;/a&#62;-based &#60;a href=&#34;https://dduan.github.io/TOMLDecoder/main/documentation/tomldecoder/&#34;&#62;documentation site&#60;/a&#62;.&#60;/li&#62;
&#60;li&#62;The entirety of the &#60;a href=&#34;https://github.com/toml-lang/toml-test&#34;&#62;official test suite&#60;/a&#62; is now programmatically imported as unit tests.&#60;/li&#62;
&#60;li&#62;The source code style is now enforced by &#60;a href=&#34;https://github.com/nicklockwood/SwiftFormat&#34;&#62;swiftformat&#60;/a&#62;.&#60;/li&#62;
&#60;li&#62;Platform checks are more comprehensive and modern on CI.&#60;/li&#62;
&#60;li&#62;Benchmarks are now modernized with &#60;a href=&#34;https://github.com/ordo-one/package-benchmark&#34;&#62;ordo-one/package-benchmark&#60;/a&#62;&#60;/li&#62;
&#60;/ul&#62;
&#60;p&#62;I think of this release as a preparation for a eventual 1.0 release,
which will support the &#60;a href=&#34;https://forums.swift.org/t/the-future-of-serialization-deserialization-apis/78585/171&#34;&#62;new deserialization APIs from Swift&#60;/a&#62;.&#60;/p&#62;
&#60;p&#62;Even through I went through some optimizations for speed in this post,
I still have a bunch of ideas I want to try to squeeze out more performance gains.
That&#39;s exciting.&#60;/p&#62;
</description>
                <pubDate>Wed, 10 Dec 2025 17:44:34 -0800</pubDate>
                <link>https://duan.ca/2025/12/10/TOMLDecoder-0.4.1/</link>
                <guid isPermaLink="true">https://duan.ca/2025/12/10/TOMLDecoder-0.4.1/</guid>
            </item>
            <item>
                <title>Making of a TOML parser</title>
                <description>&#60;p&#62;During the holidays, I spent some time on the parser that underlies &#60;a href=&#34;https://github.com/dduan/TOMLDecoder&#34;&#62;TOMLDecoder&#60;/a&#62;. The original
implementation targeted TOML&#39;s spec version 0.5. A few release-candidates for version 1.0 has come
out since then. So it&#39;s a good time to give this project attention.&#60;/p&#62;
&#60;p&#62;Back in the 0.5 days, the TOML spec was (well) written in English with a few examples for each
element in the language. The spec document both:&#60;/p&#62;
&#60;ol&#62;
&#60;li&#62;how a TOML document should be spelled out (table header should have a &#60;code&#62;[&#60;/code&#62;, followed by 0 or more
whitespace, then, a key, 0 or more whitespace, then &#60;code&#62;]&#60;/code&#62;).&#60;/li&#62;
&#60;li&#62;rules for detecting conflicts in a syntactically correct document (if &#60;code&#62;a.b&#60;/code&#62; is a table, then it&#39;s
invalid to set its value to be a date in the same document).&#60;/li&#62;
&#60;/ol&#62;
&#60;p&#62;My memory of hand-rolling a recursive-descent scanner that conforms to both of the above
requirements was unpleasant. My lesser understanding of the markup language, the vagueness for the
validation rules in the spec, as well as (I think?) poorer skill for writing parsers all contributed
to the unpleasantness. TOML has gained an ABNF for its syntax since then, making it less necessary
to reply on the English descriptions. It&#39;s the holidays, maintaining existing code is hard.&#60;/p&#62;
&#60;p&#62;So, I decided to have some fun, and re-write the parser from scratch. The rest of this post contains
notable things from the rewrite.&#60;/p&#62;
&#60;p&#62;I translated the ABNF with parser combinators. The recent &#60;a href=&#34;https://pointfree.co&#34;&#62;Pointfree&#60;/a&#62; video series made me curious
about the performance of this parsing style in Swift. At the end of the rewrite, I added benchmarks
to find out. Here&#39;s benchmark for parsing an example TOML document&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;name                    time          std        iterations
-----------------------------------------------------------
example-toml.decoder    454840.000 ns ±   3.63 %       3045
example-toml.combinator 422721.500 ns ±   4.28 %       3266
example-toml.scanner     82232.000 ns ±   9.39 %      16793
example-toml.c            5901.000 ns ±  24.72 %     216140
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;&#60;code&#62;example-toml.decoder&#60;/code&#62; is time spent on parsing + decoding. &#60;code&#62;example-toml.scanner&#60;/code&#62; is the time spent
by the old parser. &#60;code&#62;example-toml.c&#60;/code&#62; is the performance of a C library.&#60;/p&#62;
&#60;p&#62;So, the new parser is much much slower! However, I know from debugging through 200+ unit tests that,
the new parser fixed a few serious bugs compared to the old. It also conforms to diffs between
version 0.5 and 1.0 of the TOML spec. Speed alone is not good enough of a reason to throw this work
away! There&#39;s another reason the new parser is superior, but I&#39;ll talk about it later.&#60;/p&#62;
&#60;p&#62;To be fair to parser combinators, I made several decisions that preferred development speed over
runtime speed during development. These were conscious decisions. There were no benchmarks at
time so I didn&#39;t want to worry about it pre-maturely. Point is, there are rooms for significant
runtime speed improvements. Perhaps I&#39;ll write a follow-up post detailing my journey to make the
parser go fast later; the C library is part of the benchmark for a reason!&#60;/p&#62;
&#60;p&#62;I was also inspired by Joe Groff&#39;s blog post &#60;a href=&#34;http://duriansoftware.com/joe/Constructing-human-grade-parsers.html&#34;&#62;Constructing human-grade parsers&#60;/a&#62;. Instead of
stopping at the first syntax error, a parser (any parser!) should treat the error as part of its
successful output, deal with the erroneous part of the input, and recover from it. This approach
means the portion of the input after the first error gets parsed, and any error it may contain can
be found and reported, too! Joe&#39;s post explains this well.&#60;/p&#62;
&#60;p&#62;To talk about this further, let&#39;s dive into some details.&#60;/p&#62;
&#60;p&#62;As mentioned earlier, to validate a TOML document, there are rules for both syntax and semantics to
consider. TOML has a few top-level constructs: table header, array-table header, and key-value
pairs. Each of these alone can be validated purely based on syntax. On a high level, a TOML parser
can do the following:&#60;/p&#62;
&#60;ol&#62;
&#60;li&#62;parse a list of top-level constructs&#60;/li&#62;
&#60;li&#62;iterate over this list, gradually assembly the complete TOML object&#60;/li&#62;
&#60;/ol&#62;
&#60;p&#62;Errors could exist from each of these two steps To make the parser &#60;em&#62;human-grade&#60;/em&#62;, the errors must
not propagate by disrupting the parsing logic. In Swift, this means the code don&#39;t throw the
(conceptual) errors, instead, the top-level constructs include error as a possible value:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;enum TopLevel: Equatable {
    case table(Key)
    case arrayTable(Key)
    case keyValue(KeyValuePair)
    case error(Reason)
}
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;Upon evaluating a &#60;code&#62;TopLevel&#60;/code&#62; value, the parser must not stop if it generates a conflict according to
TOML&#39;s requirement. We take note of this error, and move on to consume the next &#60;code&#62;TopLevel&#60;/code&#62;. Errors
from this step will join the error from &#60;code&#62;TopLevel.error&#60;/code&#62; at the end for users to see. Therefore, the
second step&#39;s code roughly does this:&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-swift&#34;&#62;var errors = [Error]()

for value in topLevelValues {
    switch value {
    case .error(let reason):
        errors.append(reason)
    default:
        do {
            evaluate(value)
        } catch {
            errors.append(error)
        }
    }
}

if !errors.isEmpty {
    throw UserFacingError(details: errors)
}

// no error! parsing succeeded
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;This code &#38;quot;synchronizes&#38;quot; the errors from both the syntactical, and semantical level. With some
additional effort to make the errors &#60;code&#62;CustomStringConvertible&#60;/code&#62;, a erroneous TOML document such as&#60;/p&#62;
&#60;pre&#62;&#60;code class=&#34;language-TOML&#34;&#62;a = &#38;quot;Hello
b = 43
[b]
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;makes the parser generate the following error message:&#60;/p&#62;
&#60;pre&#62;&#60;code&#62;Deserialization failure:
    * Value |1, 5| Missing closing character `&#38;quot;` in string
    * Conflict |3, 2| Conflicting value at [b] Existing value is 43
&#60;/code&#62;&#60;/pre&#62;
&#60;p&#62;The explanation I presented above is simplified by a lot. In reality, the &#38;quot;human-grade&#38;quot; upgrade can
go a lot further. For example, if the definition of &#60;code&#62;a&#60;/code&#62; has a syntax error, instead of rejecting it,
as long as we can figure out what the intent is, we can pretend it&#39;s a good value. That way, any
semantic issues related to &#60;code&#62;a&#60;/code&#62; can be discovered. Improvements like this can be added to the parser
in many places still.&#60;/p&#62;
&#60;p&#62;Anyways, here&#39;s where I abruptly stop the story of my new TOML parser. There are a lot of exciting
space for improvment. So this article might be a &#38;quot;part 1&#38;quot;. No promises, though.&#60;/p&#62;
</description>
                <pubDate>Sun, 03 Jan 2021 14:56:10 -0800</pubDate>
                <link>https://duan.ca/2021/01/03/human-grade-toml-parser-in-swift/</link>
                <guid isPermaLink="true">https://duan.ca/2021/01/03/human-grade-toml-parser-in-swift/</guid>
            </item>
            <item>
                <title>TOML Decoder Playlist</title>
                <description>&#60;p&#62;I enjoyed making &#60;a href=&#34;https://github.com/dduan/TOMLDeserializer&#34;&#62;TOMLDeserializer&#60;/a&#62; and &#60;a href=&#34;https://github.com/dduan/TOMLDecoder&#34;&#62;TOMLDecoder&#60;/a&#62; recently. Let&#39;s hope
some projects will pick them up and TOML as a configuration format will start to
spead in Swift communities.&#60;/p&#62;
&#60;p&#62;What&#39;s outstanding about these projects is that I started working on them while
&#60;a href=&#34;https://twitch.tv/daniel_duan&#34;&#62;streaming&#60;/a&#62;. Personally, I consume a lot of content like this. So now people
can watch me writing Swift, too.&#60;/p&#62;
&#60;p&#62;I&#39;ve been archiving recordings of these streams as much as I can. Here are the
links to these videos, each is around 1-1.5 hours long:&#60;/p&#62;
&#60;ul&#62;
&#60;li&#62;&#60;a href=&#34;https://youtu.be/XLLlCEfuFLw&#34;&#62;Turn TOML Test Fixtures Into XCTests With Vim Macros&#60;/a&#62;&#60;/li&#62;
&#60;li&#62;&#60;a href=&#34;https://youtu.be/Ztq3K3cq8f0&#34;&#62;Passing TOML Deserialization Tests&#60;/a&#62;&#60;/li&#62;
&#60;li&#62;&#60;a href=&#34;https://youtu.be/GTCYSIc6n3U&#34;&#62;Finishing TOML Invalidation Tests&#60;/a&#62;&#60;/li&#62;
&#60;li&#62;&#60;a href=&#34;https://youtu.be/HP2Wzh8MVvg&#34;&#62;TOML Decoder: The Beginning&#60;/a&#62;&#60;/li&#62;
&#60;li&#62;&#60;a href=&#34;https://youtu.be/EZ7VpbrLkH0&#34;&#62;TOML Decoder: Filling In Missing Implementation Pieces&#60;/a&#62;&#60;/li&#62;
&#60;li&#62;&#60;a href=&#34;https://youtu.be/bISMVVWOHKg&#34;&#62;TOML Decoder: Adding The First TOML Decoding Strategy!&#60;/a&#62;&#60;/li&#62;
&#60;li&#62;&#60;a href=&#34;https://youtu.be/oOOS4bnhwx4&#34;&#62;TOML Decoder: Project Overview And Data Decoding Support&#60;/a&#62;&#60;/li&#62;
&#60;li&#62;&#60;a href=&#34;https://youtu.be/9yDtXsrMtbU&#34;&#62;TOML Decoder: Key Decoding Strategies&#60;/a&#62;&#60;/li&#62;
&#60;li&#62;&#60;a href=&#34;https://youtu.be/g1V872HL4Dk&#34;&#62;TOML Decoder: Project Updates&#60;/a&#62;&#60;/li&#62;
&#60;/ul&#62;
&#60;p&#62;The TOMLDecoder projects would&#39;ve been capture on camera entirely if I weren&#39;t
such a streaming n00b and messed up a few streams. Hilarious.&#60;/p&#62;
</description>
                <pubDate>Sun, 10 Mar 2019 20:32:37 -0700</pubDate>
                <link>https://duan.ca/2019/03/10/toml-decoder/</link>
                <guid isPermaLink="true">https://duan.ca/2019/03/10/toml-decoder/</guid>
            </item>
    </channel>
</rss>