<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Daniel Duan's Articles About Windows</title>
        <link>https://duan.ca/tag/windows/</link>
        <atom:link href="https://duan.ca/tag/windows/feed.xml" rel="self" type="application/rss+xml" />
            <item>
                <title>Fantastic Beasts in C and Where To Find Them in Swift</title>
                <description>&lt;p&gt;Swift has a pretty decent C-interoperability story. But C has many features! Today, I&#x27;ll tell you
a story involving a few not-so-well supported C features and Swift.&lt;/p&gt;
&lt;p&gt;It all started when I decided to re-write &lt;a href=&quot;https://github.com/dduan/Pathos&quot;&gt;Pathos&lt;/a&gt; with Windows support. One of the library&#x27;s
offering is reading the literal target of a symbolic link: if &lt;code&gt;b&lt;/code&gt; is a link to &lt;code&gt;a&lt;/code&gt;, then
&lt;code&gt;Path(&amp;quot;b&amp;quot;).readSymlink()&lt;/code&gt; should return a another path that&#x27;s equivalent to &lt;code&gt;Path(&amp;quot;a&amp;quot;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Windows API that returns this information is &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol&quot;&gt;DeviceIoControl&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;BOOL DeviceIoControl(
  HANDLE       hDevice,
  DWORD        dwIoControlCode,
  LPVOID       lpInBuffer,
  DWORD        nInBufferSize,
  LPVOID       lpOutBuffer,
  DWORD        nOutBufferSize,
  LPDWORD      lpBytesReturned,
  LPOVERLAPPED lpOverlapped
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice anything weird? Hint: &lt;code&gt;LPVOID&lt;/code&gt; is &lt;code&gt;void *&lt;/code&gt; in standard C.&lt;/p&gt;
&lt;p&gt;This function is, for the lack of better words, polymorphic: depending on your input, it can intake
and output different types. As a caller, it is your responsibility to look up what type is needed
and cast them to and from those &lt;code&gt;void *&lt;/code&gt;s. The size of the data structure is returned as well. We&#x27;ll
have a lot to talk about that later.&lt;/p&gt;
&lt;p&gt;Perhaps, surprisingly, this is not too hard to deal with in Swift. In my &lt;a href=&quot;/2020/09/09/free-c-strings&quot;&gt;last article&lt;/a&gt;,
I detailed how we can use an Swift API to work with C buffers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;/// get the file `handle`...
/// now call `DeviceIoControl`
var data = ContiguousArray&amp;lt;CChar&amp;gt;(
    unsafeUninitializedCapacity: kMax
) { buffer, count in
    var size: DWORD = 0
    DeviceIoControl(
        handle,
        FSCTL_GET_REPARSE_POINT,
        nil,
        0,
        buffer.baseAddress,
        DWORD(buffer.count),
        &amp;amp;size,
        nil
    )
    count = Int(size)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So this fills the array of &lt;code&gt;CChar&lt;/code&gt;s with the necessary bytes for out result. I named the variable
&lt;code&gt;data&lt;/code&gt; because it is exactly the same concept as &lt;code&gt;Foundation&lt;/code&gt;&#x27;s Data, as most Swift programmers
know.&lt;/p&gt;
&lt;p&gt;As promised, we&#x27;ll cast this data to the actual type so that we can retrieve information from its
bytes. Side note: casting in this context is a documented usage, So it really is more awkward rather
than bad. And there&#x27;s a safe way to do it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;withUnsafePointer(to: data) {
    $0.withMemoryRebound(
        to: [ReparseDataBuffer].self,
        capacity: 1
    ) { buffer in
        // first element in `buffer` is 
        /// a `ReparseDataBuffer`! Yay
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;It&#x27;s very important to note that &lt;code&gt;ReparseDataBuffer&lt;/code&gt; is a struct with fixed, predictable layout,
that the API &lt;code&gt;DeviceIoControl&lt;/code&gt; promises to return. In practice, this means it is defined in C. Swift
does not currently guarantee struct layout. So unless you really know what you are doing and don&#x27;t
care about forward compatibility, you should not do this with Swift structs.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So far this story has been boring for avid Swift programmers. Fear not, things will get spicy now.&lt;/p&gt;
&lt;p&gt;Let&#x27;s talk about this &lt;code&gt;ReparseDataBuffer&lt;/code&gt;. It&#x27;s an imported C type with a few notable features.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct {
  unsigned long  ReparseTag;
  unsigned short ReparseDataLength;
  unsigned short Reserved;
  union {
    struct {
      unsigned short SubstituteNameOffset;
      unsigned short SubstituteNameLength;
      unsigned short PrintNameOffset;
      unsigned short PrintNameLength;
      unsigned long  Flags;
      wchar_t  PathBuffer[1];
    } SymbolicLinkReparseBuffer;
    struct {
      unsigned short SubstituteNameOffset;
      unsigned short SubstituteNameLength;
      unsigned short PrintNameOffset;
      unsigned short PrintNameLength;
      wchar_t  PathBuffer[1];
    } MountPointReparseBuffer;
    struct {
      unsigned char DataBuffer[1];
    } GenericReparseBuffer;
  };
} ReparseDataBuffer;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Feature #1: it has a &lt;em&gt;union member&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;union&lt;/code&gt; in C is an area in memory that could be any of the types specified in the union:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// X.a is a `char` and X.b is a `uint64_t`. 
// And they occupy the same memory because
// only 1 of them exists at a time.
typedef union {
    char a;
    uint64_t b;
} X;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Swift does not own a direct analog for this. So if we import this &lt;code&gt;ReparseDataBuffer&lt;/code&gt; definition,
there wouldn&#x27;t be a good way to access the data inside the union.&lt;/p&gt;
&lt;p&gt;As I pointed out in the comment, members of a union occupy the same space in memory. The largest
member defines the size of that space, so everyone can fit inside of it. Each union member
interprets the same bytes according to their own definition. Given this knowledge, we can derive
a solution that works around Swift&#x27;s limitations: break up the union (sorry, this whole paragraph
reads super suggestive of the real world union. It&#x27;s probably why this word is picked for this data
structure in the first place. But I do not intend to say anything about the real world here)!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct {
  unsigned long reparseTag;
  unsigned short reparseDataLength;
  unsigned short reserved;
  unsigned short substituteNameOffset;
  unsigned short substituteNameLength;
  unsigned short printNameOffset;
  unsigned short printNameLength;
  unsigned long flags;
  wchar_t pathBuffer[1];
} SymbolicLinkReparseBuffer;

typedef struct {
  unsigned long reparseTag;
  unsigned short reparseDataLength;
  unsigned short reserved;
  unsigned short substituteNameOffset;
  unsigned short substituteNameLength;
  unsigned short printNameOffset;
  unsigned short printNameLength;
  wchar_t pathBuffer[1];
} MountPointReparseBuffer;

// we don&#x27;t care about the 3rd union
// member in this use case
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Conveniently for us, the union member in &lt;code&gt;ReparseDataBuffer&lt;/code&gt; is at the end. So we don&#x27;t need to
worry about padding the unused space for smaller alternatives. Back in Swift, instead of dealing
with &lt;code&gt;ReparseDataBuffer&lt;/code&gt; directly, we can work with &lt;code&gt;SymbolicLinkReparseBuffer&lt;/code&gt; or
&lt;code&gt;MountPointReparseBuffer&lt;/code&gt;, depending on our expectation of which union member to read.&lt;/p&gt;
&lt;p&gt;Yeah, this is a good time to mention that, &lt;a href=&quot;https://github.com/dduan/Pathos&quot;&gt;Pathos&lt;/a&gt; has to include copies of these definition in a
separate C module. Not only because we need to &amp;quot;break up the union&amp;quot;, the original definition is also
only accessible after importing some headers in the NT kernel. So the standard &lt;code&gt;import WinSDK&lt;/code&gt; won&#x27;t
suffice.&lt;/p&gt;
&lt;p&gt;Moving on to notable feature #2. The last member of both &lt;code&gt;SymbolicLinkReparseBuffer&lt;/code&gt; and
&lt;code&gt;MountPointReparseBuffer&lt;/code&gt; &lt;code&gt;pathBuffer&lt;/code&gt; is a 1-character long array...why?&lt;/p&gt;
&lt;p&gt;In C, this is a &lt;em&gt;flexible array member&lt;/em&gt;. Such member must always appear at the end of a struct.
The word &amp;quot;flexible&amp;quot; in this context refers to the amount of memory allocated for this type of
structs : it can vary according to the length of the array as needed. The member such as
&lt;code&gt;pathBuffer&lt;/code&gt; is here to provide access to the beginning of the buffer.&lt;/p&gt;
&lt;p&gt;To Swift, &lt;code&gt;pathBuffer&lt;/code&gt; looks like a single &lt;code&gt;UInt16&lt;/code&gt;. The language obviously don&#x27;t have a good idea
of this C feature. So how to we get the rest of the data from this array?&lt;/p&gt;
&lt;p&gt;Once again, we have to lean on our understanding of memory layout in C structs.&lt;/p&gt;
&lt;p&gt;As is common in APIs for flexible array members, the length of the array trailing the struct is
provide to us. Let&#x27;s call it &lt;code&gt;flexibleLength&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/2020/09/flexible_array_member.png&quot; alt=&quot;Illustration of memory layout for a C struct with flexible array member&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We already have the memory for these structs in bytes (remember &lt;code&gt;data&lt;/code&gt;?). And we can get the size
for the fixed potion of the structs with&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;let fixedStructSize = MemoryLayout&amp;lt;
    SymbolicLinkReparseBuffer
&amp;gt;.stride
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Putting it all together, we can get the full content of the array by&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;chopping off the content for struct itself,&lt;/li&gt;
&lt;li&gt;casting the rest of the raw buffer to the expected element type, and&lt;/li&gt;
&lt;li&gt;include the last member in this struct as the first element in the array&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;// Include the first element, which is at
// the end of the fixed struct potion.
let arrayStart = fixedStructSize - 1
// Cast the data buffer so it&#x27;s composed 
// of `wchar_t` aka `UInt16`s.
let array = withUnsafePointer(to: data) {
    $0.withMemoryRebound(
        to: [UInt16].self,
        capacity: data.count / 2
    ) { sixteenBitData in
        // chop off the non-array potion
        sixteenBitData.pointee[
            arrayStart ..&amp;lt; (arrayStart + flexibleLength)
        ]
    }
}

// now, go nuts on the array! You earned it!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Considerations such as error handling are intentionally left out in this article. You can checkout
the source code of &lt;a href=&quot;https://github.com/dduan/Pathos&quot;&gt;Pathos&lt;/a&gt; (on the &lt;code&gt;next&lt;/code&gt; branch) for the full glory.&lt;/p&gt;
&lt;p&gt;Anyways, the flexible array member turns out to be the literal target of the symbolic link. So here
is the end of our story. I&#x27;m interested to hear about alternative approaches for dealing with union
members and flexible array members in Swift. Let me know on &lt;a href=&quot;https://twitter.com/daniel_duan&quot;&gt;Twitter&lt;/a&gt;, or &lt;a href=&quot;&quot;&gt;Twitch&lt;/a&gt; when I&#x27;m
streaming!&lt;/p&gt;
</description>
                <pubDate>Sat, 12 Sep 2020 23:11:48 -0700</pubDate>
                <link>https://duan.ca/2020/09/12/fantastic-c-beasts-and-where-to-find-them-in-swift/</link>
                <guid isPermaLink="true">https://duan.ca/2020/09/12/fantastic-c-beasts-and-where-to-find-them-in-swift/</guid>
            </item>
            <item>
                <title>Introducing Dye</title>
                <description>&lt;p&gt;&lt;em&gt;Recently, I got a PC. And I started writing some code on Windows for the
giggles. Naturally, I gravitate towards stuff I use on macOS and Linux when it
comes to tooling. To my delight, NeoVim, ripgrep and fzf all work out of the box
in terminal simulators, which brings us to todays main topic...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I made a terminal coloring library for Swift that works on Windows,
&lt;a href=&quot;https://github.com/dduan/Dye/releases/tag/0.0.1&quot;&gt;Dye 0.0.1 is available now&lt;/a&gt;!&lt;/p&gt;
&lt;h2&gt;So, why?&lt;/h2&gt;
&lt;p&gt;When I started working on &lt;a href=&quot;https://github.com/dduan/tre&quot;&gt;tre&lt;/a&gt;, I search in the
Rust ecosystem for a CLI interface library that supports as many platforms as
possible. Eventually I found &lt;a href=&quot;https://github.com/BurntSushi/termcolor&quot;&gt;termcolor&lt;/a&gt; among an ocean of options. As
a result, tre, like a lot of other CLI tools (like rg) written in Rust, has
a consistent UI on Windows and Unix. This experience has brought lots of joy, as
a user of both the library, and the app. I want to pay it forward to my fellow
Swift CLI makers, and their users.&lt;/p&gt;
&lt;p&gt;Zooming out slightly, success of Swift on Windows makes Swift as a skill more
valuable. And &lt;a href=&quot;https://duan.ca/2019/01/20/kick-ass-cli-tools-in-swift/&quot;&gt;I want more CLI tools written in Swift&lt;/a&gt;. So it&#x27;s
a double-win, really.&lt;/p&gt;
&lt;p&gt;Lastly, it&#x27;s a small library, all things considered. Being able to get it to
a shippable state on a weekend is a key reason I decided to work on it.&lt;/p&gt;
&lt;h2&gt;Technical tidbits&lt;/h2&gt;
&lt;p&gt;I love Max Howell&#x27;s &lt;a href=&quot;https://github.com/mxcl/Chalk&quot;&gt;Chalk&lt;/a&gt; library. It&#x27;s a 100-line Swift file that
implements &lt;a href=&quot;https://en.wikipedia.org/wiki/ANSI_escape_code&quot;&gt;ANSI escape code&lt;/a&gt; with Swift&#x27;s custom string interpolation
API. It demonstrates well how simple it is to customize your terminal output.&lt;/p&gt;
&lt;p&gt;Enter Windows, where ANSI sequences are ignored by built-in terminal simulators
from the past. The console is customized via a entirely separate, stateful,
imperative APIs (Newer simulators such as the freshly released &lt;a href=&quot;&quot;&gt;Terminal&lt;/a&gt;
actually supports ANSI codes pretty well). This is our lowest common API
denominator, which ultimately dictated the design of Dye.&lt;/p&gt;
&lt;p&gt;Dye&#x27;s API is centered around Swift&#x27;s built-in protocol &lt;code&gt;TextOutputStream&lt;/code&gt;. You
create a stream object and mutate the style need for upcoming output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;let output = OutputStream.standardOutput()
output.color.foreground = .blue
print(&amp;quot;blue text&amp;quot;, to &amp;amp;stream) // blue text is blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the stream is redirected to something other than the terminal, styling gets
automatically disabled. There are various options to customize this behavior.&lt;/p&gt;
&lt;p&gt;Take a look at this &lt;a href=&quot;https://github.com/dduan/Dye/blob/master/Examples/main.swift&quot;&gt;sample app&lt;/a&gt; to get a more concrete picture of
how things work.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I&#x27;ll end with a screenshot of the sample app running in Command Prompt:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/2020/06/01/windows-example-screenshot.jpg&quot; alt=&quot;Dye sample app running in Windows Command Prompt&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Let&#x27;s build more.&lt;/p&gt;
</description>
                <pubDate>Mon, 01 Jun 2020 15:08:01 -0700</pubDate>
                <link>https://duan.ca/2020/06/01/dye/</link>
                <guid isPermaLink="true">https://duan.ca/2020/06/01/dye/</guid>
            </item>
    </channel>
</rss>